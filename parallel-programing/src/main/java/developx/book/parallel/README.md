# 1 개요
## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사 
- 자원활용: 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 것이 효율적이다.
- 공정성 : 한 번에 프로그램 하나를 끝까지 실행해 종료하는 것보다 작은 단위로 컴퓨터를 공유하는 방법이 바람직하다.
- 편의성: 일을 하나씩 처리하고 필요시 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.

## 1.2 스레드의 이점
- 제대로만 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상 시킬수 있다. 
- 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬어진다. 

### 1.2.1 멀티프로세서 활용
- 프로세스 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
- 멀티스레드 프로그램에선 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.

### 1.2.2 단순한 모델링 
- 한 종류 일을 순차적으로 처리하는 프로그램은 작성하기도 쉽고 오류도 잘 생기지 않는다.
- 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 숭행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.

### 1.2.3 단순한 비동기 이벤트 처리 
- 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하면 개발작업이 쉬워진다.
- 단일 스레드 서버 프로그램의 경우 복잡하고, 실수하기 쉬운 넌블로킹 I/O를 써야만 한다.

### 1.2.4 더 빨리 반응하는 사용자 인터페이스 
- AWT나 스윙같은 GUI 프레임웍은 메인 이벤트 루프를 이벤트 전달 스레드로 대체했다. 
- 사용자 인터페이스 이벤트가 발생하면 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출된다.

## 1.3 스레드 사용의 위험성
- 개발자라면 대부분 스레드 안정성에 대해 잘 알아야 한다.

### 1.3.1 안정성 위해 요소 
- 스레드가 하나일 때는 아무런 문제가 없는 프로그램도 여러 스세드에서는 제대로 수행되지 않을 수 있다. 
- @NotThreadSafe, @ThreadSafe 어노테이션을 문서화하자.
- 실행 과정에서 연산이 어떻게 서로를 간섭하느냐에 따라 결과가 달라질 수 있는 현상을 경쟁 조건이라고 한다.

### 1.3.2 활동성 위험
- 어떤 작업이 전혀 진전되지 못하는 현상태에 빠질 때 활동성 장애가 발생했다고 한다.
- deadlock, starvation, livelock 등 여러 가지 활동성 장애 유형이 있다.

### 1.3.3 성능 위험
- 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 이는 상당한 부담이 생긴다.
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다.

## 1.4 스레드는 어디에나
- 모든 자바 프로그램은 기본적으로 스레드를 사용한다.
- 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임쿽에서 스레드를 생성할 수 있다. 
- 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 한다.

<br/>

# 2 스레드 안정성
- 스레드에 안전한 코드를 작성하는 것은 근본적으로 상태, 특히 공유되고 변경할 수 있는 상태에 접근을 관리하는 것이다.
- 여러 스레드가 변경할 수 있는 하나의 상태 변수를 접근하는 방법 세가지
  - 해당 상태 변수를 스레드 간에 공유하지 않는다.
  - 해당 상태 변수를 변경 할 수 없게 만든다.
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.
- 스레드 안전한 클래스를 설계할 떈 캡슐화와 불변 객체를 잘 활용하고, 불변 조건을 명확하게 기술해야 한다.

## 2.1 스레드 안정성이란?
- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워넣는 상관없다.
- 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다. 
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.

### 2.1.1 상태 없는 서블릿 
- 상태 없는 객체는 항상 스레드 안전하다.
- 여러 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

## 2.2 단일 연산
- 나눌 수 없는 최소 단위의 작업을 실행되는 연산

### 2.2.1 경쟁 조건 
- 병렬 프로그램의 입장에서 타이밍이 안 좋을 때 결과가 잘못된 가능성은 중요한 개념이기 때문에 경쟁 조건이라는 용어로 정의한다.
- 경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실해하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.

### 2.2.2 늦은 초기화 시 경쟁조건 
- 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것이다.
- 아래 코드는 동시에 여러 스레드에서 호출시 서로 다른 인스턴스를 가져갈 수 있는 문제가 있다.
```java
@NotThreadSafe
public class LazyInitRace {
    private String instance = null;
    public String getInstance(){
        if(instance == null) {
            instance = new String();
        }
        return instance;
    }
}
```

### 2.2.3 복합 동작 
- 작업 A를 실행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행되었거나 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 B는 단일 연산
- 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작이라고 한다. 
- 스레드에 안전하기 위해서는 복합 동작이 단일 연산으로 실행되어야 한다. (Lock 사용)
- 가능하면 Atomicxx 같은 이미 만들어져 있는 스레드 안전한 객체를 사용하는 편이 좋다. 

```java
import java.util.concurrent.atomic.AtomicLong;

@ThreadSafe
public class CountingService {

  private final AtomicLong count = new AtomicLong(0);

  public long  getCount(){
      return count.get();
  }

  public void service(){
      count.incrementAndGet();
  }
}
```


## 2.3 락 
- 여러 개의 변수가 하나의 불변조건을 구성하고 있다면, 이 변수들은 서로 독립적이지 않다. 
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.

### 2.3.1 암묵적인 락 
- 자바에는 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공한다. 
- 이와 같이 자바에 내장된 락을 암죽적인 락 혹은 모니터 락이라 한다. 
- 자바에서 암묵적인 락은 뮤텍스(상호 배제 락)로 한 번에 한 스레드만 특정 락을 소유할 수 있다.
- synchronized 는 아주 쉽게 단일 연산으로 만들 수 있지만 성능에 문제가 있을 수 있다. 

### 2.3.2 재진입성
- 암묵적인 락은 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있는 특징을 재진입성이라고 한다.

## 2.4 락으로 상태 보호하기 
- 여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 한다. 
- 여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 한다.

## 2.5 활동성과 성능 
- 동기화 정책을 수현할 때는 성능을 위해 조급하게 단순성(잠재적으로 안정성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.
- 복잡하고 오래 걸리는 계산 작업, 네트워 작업, 입출력 작업과 같이 빨리 끝나지 않으 수 있는 작업은 가능한 락을 잡으면 안된다.


<br/>

# 3 객체 공유
- 여러 스레드에서 특정 객체를 동시에 사용하려 할 때 썩이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법

## 3.1 가시성
- 특정 변수에 값을 지정하고 다음번에 다시 값을 읽어보면, 이전에 저장해뒀던 바로 그 값을 가져올 수 있다.
- 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용해야 한다.
- 재배치 현상은 특정 메소의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제
- 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 경우가 발생할 수도 있기 때문이다.

### 3.1.1 스테일 데이터
- 최신값이 아닌 이전에 저장된 데이터를 의미
- 공유 변수를 적절한 방법으로 동기화 시키지 않으면 다른 스레드에서 값을 제대로 사용하지 못하는 경우도 생길 수 있다.

### 3.1.2 단일하지 않는 64비트 연산
- 64비트를 사용하는 숫자형(double, long 등) 에서 동기화를 사용하지 않는 경우 난데없는 값이 생길 가능성도 존재


### 3.1.3 락과 가시성
- synchronized 와 같은 락은 상호배제뿐만 아니라 메모리 가시성을 확보하기 위해서도 사용한다. 
- 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야한다.

### 3.1.4 volatile
- volatile 로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어 갈 수 있도록 해준다. 
- volatile 키워드를 사용하여 변수를 선언하면, 컴파일러와 런타임 모두 이 변수는 공유해 사용하고 실행순서를 재배치 해서는 안된다고 이해한다.
- 락을 사용하면 가시성과 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성을 보장하지 못하고 가시성만 보장한다.
- volatile 변수는 다음과 같은 상황에서만 사용
  - 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
  - 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
  - 해당 변수를 사용하는 동안에는 어떤 경우에도 락을 걸어 둘 필요가 없는 경우
  
## 3.2 공개와 유출 
- 특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 한다. 
- 의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우을 유출 상태라고 한다.
```java
class UnsafeStates {
    // private 공개되지 않은 변수지만 getStates 를 통해 값이 변경될 수 있는 문제점이 있다. 
    private String[] states = new String[]{"AK", "AL"};
    public String[] getStates() {
        return states;
    }
}
```

## 3.2.1 생성 메소드 안정성
- 