# 1 개요
## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사 
- 자원활용: 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 것이 효율적이다.
- 공정성 : 한 번에 프로그램 하나를 끝까지 실행해 종료하는 것보다 작은 단위로 컴퓨터를 공유하는 방법이 바람직하다.
- 편의성: 일을 하나씩 처리하고 필요시 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.

## 1.2 스레드의 이점
- 제대로만 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상 시킬수 있다. 
- 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬어진다. 

### 1.2.1 멀티프로세서 활용
- 프로세스 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
- 멀티스레드 프로그램에선 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.

### 1.2.2 단순한 모델링 
- 한 종류 일을 순차적으로 처리하는 프로그램은 작성하기도 쉽고 오류도 잘 생기지 않는다.
- 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 숭행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.

### 1.2.3 단순한 비동기 이벤트 처리 
- 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하면 개발작업이 쉬워진다.
- 단일 스레드 서버 프로그램의 경우 복잡하고, 실수하기 쉬운 넌블로킹 I/O를 써야만 한다.

### 1.2.4 더 빨리 반응하는 사용자 인터페이스 
- AWT나 스윙같은 GUI 프레임웍은 메인 이벤트 루프를 이벤트 전달 스레드로 대체했다. 
- 사용자 인터페이스 이벤트가 발생하면 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출된다.

## 1.3 스레드 사용의 위험성
- 개발자라면 대부분 스레드 안정성에 대해 잘 알아야 한다.

### 1.3.1 안정성 위해 요소 
- 스레드가 하나일 때는 아무런 문제가 없는 프로그램도 여러 스세드에서는 제대로 수행되지 않을 수 있다. 
- @NotThreadSafe, @ThreadSafe 어노테이션을 문서화하자.
- 실행 과정에서 연산이 어떻게 서로를 간섭하느냐에 따라 결과가 달라질 수 있는 현상을 경쟁 조건이라고 한다.

### 1.3.2 활동성 위험
- 어떤 작업이 전혀 진전되지 못하는 현상태에 빠질 때 활동성 장애가 발생했다고 한다.
- deadlock, starvation, livelock 등 여러 가지 활동성 장애 유형이 있다.

### 1.3.3 성능 위험
- 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 이는 상당한 부담이 생긴다.
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다.

## 1.4 스레드는 어디에나
- 모든 자바 프로그램은 기본적으로 스레드를 사용한다.
- 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임쿽에서 스레드를 생성할 수 있다. 
- 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 한다.

<br/>

# 2 스레드 안정성
- 스레드에 안전한 코드를 작성하는 것은 근본적으로 상태, 특히 공유되고 변경할 수 있는 상태에 접근을 관리하는 것이다.
- 여러 스레드가 변경할 수 있는 하나의 상태 변수를 접근하는 방법 세가지
  - 해당 상태 변수를 스레드 간에 공유하지 않는다.
  - 해당 상태 변수를 변경 할 수 없게 만든다.
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.
- 스레드 안전한 클래스를 설계할 떈 캡슐화와 불변 객체를 잘 활용하고, 불변 조건을 명확하게 기술해야 한다.

## 2.1 스레드 안정성이란?
- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워넣는 상관없다.
- 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다. 
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.

### 2.1.1 상태 없는 서블릿 
- 상태 없는 객체는 항상 스레드 안전하다.
- 여러 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

## 2.2 단일 연산
- 나눌 수 없는 최소 단위의 작업을 실행되는 연산

### 2.2.1 경쟁 조건 
- 병렬 프로그램의 입장에서 타이밍이 안 좋을 때 결과가 잘못된 가능성은 중요한 개념이기 때문에 경쟁 조건이라는 용어로 정의한다.
- 경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실해하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.

### 2.2.2 늦은 초기화 시 경쟁조건 
- 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것이다.
- 아래 코드는 동시에 여러 스레드에서 호출시 서로 다른 인스턴스를 가져갈 수 있는 문제가 있다.
```java
@NotThreadSafe
public class LazyInitRace {
    private String instance = null;
    public String getInstance(){
        if(instance == null) {
            instance = new String();
        }
        return instance;
    }
}
```

### 2.2.3 복합 동작 
- 작업 A를 실행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행되었거나 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 B는 단일 연산
- 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작이라고 한다. 
- 스레드에 안전하기 위해서는 복합 동작이 단일 연산으로 실행되어야 한다. (Lock 사용)
- 가능하면 Atomicxx 같은 이미 만들어져 있는 스레드 안전한 객체를 사용하는 편이 좋다. 

```java
import java.util.concurrent.atomic.AtomicLong;

@ThreadSafe
public class CountingService {

  private final AtomicLong count = new AtomicLong(0);

  public long  getCount(){
      return count.get();
  }

  public void service(){
      count.incrementAndGet();
  }
}
```


## 2.3 락 
- 여러 개의 변수가 하나의 불변조건을 구성하고 있다면, 이 변수들은 서로 독립적이지 않다. 
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.

### 2.3.1 암묵적인 락 
- 자바에는 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공한다. 
- 이와 같이 자바에 내장된 락을 암죽적인 락 혹은 모니터 락이라 한다. 
- 자바에서 암묵적인 락은 뮤텍스(상호 배제 락)로 한 번에 한 스레드만 특정 락을 소유할 수 있다.
- synchronized 는 아주 쉽게 단일 연산으로 만들 수 있지만 성능에 문제가 있을 수 있다. 

### 2.3.2 재진입성
- 암묵적인 락은 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있는 특징을 재진입성이라고 한다.

## 2.4 락으로 상태 보호하기 
- 
