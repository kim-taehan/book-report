# 1 개요
## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사 
- 자원활용: 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 것이 효율적이다.
- 공정성 : 한 번에 프로그램 하나를 끝까지 실행해 종료하는 것보다 작은 단위로 컴퓨터를 공유하는 방법이 바람직하다.
- 편의성: 일을 하나씩 처리하고 필요시 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.

## 1.2 스레드의 이점
- 제대로만 사용하면 개발 및 유지 보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상 시킬수 있다. 
- 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용하는 방식을 모델링하기 쉬어진다. 

### 1.2.1 멀티프로세서 활용
- 프로세스 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
- 멀티스레드 프로그램에선 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.

### 1.2.2 단순한 모델링 
- 한 종류 일을 순차적으로 처리하는 프로그램은 작성하기도 쉽고 오류도 잘 생기지 않는다.
- 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 숭행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.

### 1.2.3 단순한 비동기 이벤트 처리 
- 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하면 개발작업이 쉬워진다.
- 단일 스레드 서버 프로그램의 경우 복잡하고, 실수하기 쉬운 넌블로킹 I/O를 써야만 한다.

### 1.2.4 더 빨리 반응하는 사용자 인터페이스 
- AWT나 스윙같은 GUI 프레임웍은 메인 이벤트 루프를 이벤트 전달 스레드로 대체했다. 
- 사용자 인터페이스 이벤트가 발생하면 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출된다.

## 1.3 스레드 사용의 위험성
- 개발자라면 대부분 스레드 안정성에 대해 잘 알아야 한다.

### 1.3.1 안정성 위해 요소 
- 스레드가 하나일 때는 아무런 문제가 없는 프로그램도 여러 스세드에서는 제대로 수행되지 않을 수 있다. 
- @NotThreadSafe, @ThreadSafe 어노테이션을 문서화하자.
- 실행 과정에서 연산이 어떻게 서로를 간섭하느냐에 따라 결과가 달라질 수 있는 현상을 경쟁 조건이라고 한다.

### 1.3.2 활동성 위험
- 어떤 작업이 전혀 진전되지 못하는 현상태에 빠질 때 활동성 장애가 발생했다고 한다.
- deadlock, starvation, livelock 등 여러 가지 활동성 장애 유형이 있다.

### 1.3.3 성능 위험
- 스레드가 많은 프로그램에서는 컨텍스트 스위칭이 더 빈번하고, 이는 상당한 부담이 생긴다.
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있다.

## 1.4 스레드는 어디에나
- 모든 자바 프로그램은 기본적으로 스레드를 사용한다.
- 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임쿽에서 스레드를 생성할 수 있다. 
- 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 한다.

<br/>

# 2 스레드 안정성
- 스레드에 안전한 코드를 작성하는 것은 근본적으로 상태, 특히 공유되고 변경할 수 있는 상태에 접근을 관리하는 것이다.
- 여러 스레드가 변경할 수 있는 하나의 상태 변수를 접근하는 방법 세가지
  - 해당 상태 변수를 스레드 간에 공유하지 않는다.
  - 해당 상태 변수를 변경 할 수 없게 만든다.
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.
- 스레드 안전한 클래스를 설계할 떈 캡슐화와 불변 객체를 잘 활용하고, 불변 조건을 명확하게 기술해야 한다.

## 2.1 스레드 안정성이란?
- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어디에 끼워넣는 상관없다.
- 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다. 
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화한다.

### 2.1.1 상태 없는 서블릿 
- 상태 없는 객체는 항상 스레드 안전하다.
- 여러 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

## 2.2 단일 연산
### 2.2.1 경쟁 조건 
- 병렬 프로그램의 입장에서 타이밍이 안 좋을 때 결과가 잘못된 가능성은 중요한 개념이기 때문에 경재 조건이라는 용어로 정의한다.
- 경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실해하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.

### 2.2.2 늦은 초기화 시 경쟁조건 
- 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한 번만 초기화 되도록 하기 위한 것이다.
- 아래 코드는 동시에 여러 스레드에서 호출시 서로 다른 인스턴스를 가져갈 수 있는 문제가 있다.
```java
@NotThreadSafe
public class LazyInitRace {
    private String instance = null;
    public String getInstance(){
        if(instance == null) {
            instance = new String();
        }
        return instance;
    }
}
```

### 2.2.3 복합 동작 
- 