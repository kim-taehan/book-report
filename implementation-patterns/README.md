
# 켄트 벡의 구현 패턴 (읽기 수위 코드를 작성하는 77가지 자바 코딩 비법)
   
## 02 패턴
- 대부분의 프로그램에 적용되는 법칙 
  > - 프로그램을 새로 짜는 경우보다는 기존 프로그램을 읽는 경우가 많다.  
  > - 프로그램에 있어 '완성'은 없다 최초에 프로그램을 개발하는 뎅 드는 노력보다는 이후 프로그램을 수정하는 데 들어가는 노력이 더 크다  
  > - 프로그램 구조는 몇 가지 상태와 제어 흐름 개념으로 결정된다.  
  > - 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다. 
  세부사항을 이해해야 전체 개념에 대한 그림을 그릴 수 있고, 한편 전체 개념을 이해해야 세부적인 구현내용을 이해할 수 있기 떄문에다.
- 패턴은 이러한 프로그램 사이의 공통점을 기반으로 한다.

## 03 프로그래밍 이론
- 각 패턴에서 설명하는 이론 외에도 결정 사항에 영향을 미치는 많은 동력이 존재한다. 
  - 가치: 커뮤니케이션, 단순성, 유연성의 가치는 프로그램밍 할 떄 내리는 모든 의사결정에 영향을 미친다. 
  - 원칙: 중요하지만 떄로는 직접 정용하기 어려운 가치와, 적용법은 명확하지만 지엽적인 패턴 사이의 가교 역할을 하는 것이 바로 원칙이다.

### 가치 
- 훌륭한 프로그래밍에 있어 공통적인 가치는 커뮤니케이션, 단순성, 유연성이다. 

#### 커뮤니케이션 
- 개발자가 코드를 쉽게 이해하고, 수정하고, 사용할 수 있다면 그 코드는 개발자와 커뮤니케이션을 하고 있다고 할 수 있다. 
- 타인을 고려해서 프로그램을 짜면 코드를 이해하기 쉽고 깔끔해지며, 더 효율적이 되고 생각은 명확해진다. 
  새로운 관점에서 코드를 바라보게 되고, 다른 사람도 볼 수 있는 코드가 만들어진다. 

#### 단순성
- 복잡도를 낮추면 프로그램을 읽고 사용하고 수정하는 사람들이 프로그램을 훨씬 빨리 이해할수 있다. 
- 단순성은 독자의 수준에 따라 달라진다. 각종 프로그래밍 도구에 능숙한 전문 프로그래머에게는 단순한 내용이 초보자에게는 매우 복잡해볼일 수 있다. 
- 좋은 글을 쓰기 위해 독자층을 고려해야 하는 것처럼 좋은 프로그램을 작성하기 위해서는 독자 수준을 고려해야 한다. 

#### 유연성 
- 유연성은 비효울적인 코딩이나 설계를 정당화해주는 가치이다. 프로그램 개발 비용은 대부분 처음 프로그램이 작성된 후부터 들어간다는 점을 고려하면 프로그램 수정은 가급적 쉬워야 한다.
- 유연성은 복잡도를 증가시킨다. 하지만 이후의 프로그램 수정은 더욱 간단해진다. 

### 원칙
- 구현 패턴의 근간이 되는 몇가지 원칙을 알아본다. 

#### 지역적 변화
- 코드를 수정할 때 함께 바꿔야 하는 부분을 최소화하라. 프로그램의 어떤 부분을 수정한 것이 다른 부분에서 문제를 일으킬수 있으면 수정에 대한 비용이 증가한다. 
- 구현패턴을 사용하는 중요한 이유는 프로그램 수정 비용을 낮추기 위함인 것을 기억하자.

#### 최소중복
- 중복된 코드가 많으면 코드 수정이 어려워진다. 
- 중복을 없애는 한 가지 방법은 프로그램을 여러 작은 부분-짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지로 나누는 것이다. 

#### 로직과 데이터의 결합
- 데이터와 그 데이터를 처리하는 로직을 밀접하게-가급적 같은 메소드 혹은 같은 객체 내에 배치하라.
- 프로그램 수정하는 경우 로직과 데이터를 모두 고쳐야 하는 경우가 많다.

#### 대칭성 
- 코드의 대칭성은 하나의 아이디어를 프로그램 전체에서 일관된 방식으로 표현하는 통일성이라고 할 수 있다. 

#### 선언적 표현 
- 수행 순서가 중요한 구문이나 조건부 구분이 없는 일반 구문의 경우, 선언적 표현을 통해 코드를 작성하는 것이 이해하기 쉽다. 

#### 변화율
- 함께 변하는 로직과 데이터를 함께 관리하고, 변화율이 다른 로직과 데이터는 분리하는 것이다. 


## 04 동기유발 
- 소프트웨어 비용은 최초 개발비용과 유지비용으로 구분할 수 있고, 대부분은 유지 보수에 비용이 더 들어간다.
- 필자가 사용하는 비용 절감 전략은 커뮤니케이션하기 쉬운 코드를 짬으로써, 유지보수 비용을 줄인다. 

## 05 클래스 
- 클래스: 이 데이터들은 함꼐 사용되는데, 그에 관련된 로직이 이것이다.
- 단순한 상위클래스 이름: 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다. 
- 한정적 하위클래스 이름: 상위 클래스와의 유사점과 차이점을 분명히 드러낸다.
- 추상 인터페이스: 인터페이스와 구현을 분리한다. 
- 인터페이스: 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
- 버전 인터페이스: 하위인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다. 
- 추상 클래스: 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
- 값 객체: 산술 값처럼 동작하는 객체를 사용
- 특화: 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
- 하위클래스: 1차원적 변화는 하위클래스를 사용해서 표현한다. 
- 구현자: 연산내용이 변경되면 기존 메소드를 오버라이드해서 사용
- 내부클래스: 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사요
- 인스턴스별 행동: 인스턴스에 따라 로직에 변화
- 조건문: 명시적 조건에 따라 로직에 변화
- 위임: 여러 종류의 객체 중 하나에 위임해서 로직에 변화
- 플러그인 선택자: 리플랙션을 이용한 메소드 호출로 로직에 변화
- 익명 내부 클래스: 필요한 메소드에서 한두개의 메소드만 오버라이드 하는 객체를 사용
- 라이브러리 클래스: 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드

### 클래스 
- 클래스 계층을 구성하는 것은 일종의 압축 기법을 사용하는 것으로 상위클래스의 코드를 모두 하위 클래스에 붙여 넣는 것과 같은 효과
- 하위 클래스를 생성하는 것은 상위 클래스와 비슷하지만, 약간 다르다고 이야기 하는 것이다. 

#### 단순한 상위 클래스 이름 
- 중요한 클래스에 대해서는 한 단어로 된 이름을 사용하는 것이 좋다.
- 메타포(은유)를 사용하여 단어 하나만으로도 연상작용을 통해 여러관련 정보와 내포된 의미를 전달할 수 있다.

#### 한정적 하위클래스 이름 
- 상위 클래스와의 유사점과 차이점을 분명히 드러낸다.
- 어느 정도 간결성은 포기하고, 표현성을 택하는 편이 낫다. 보통은 상위 클래스에 한 두개의 수식어를 붙어 정한다. 
- 하지만 하위클래스가 프로그램의 중요한 개념을 의미하는 경우에는 단순한 이름을 사용해야 한다. 
  - Figure->handle->StretchyHandle, TransparencyHandle

#### 추상 인터페이스 
- 구현이 아니라 인터페이스에 맞춰 코딩하라는 말이 있다. 설계상의 결정을 필요 이상으로 노출하지 말자는 뜻이다.
- 대부분의 코드가 컬렉션 인터페이스를 사용한다면, 구상 클래스는 나중에 변경할 수 있고, 실제 연산하기 전에만 결정되면 된다.

#### 인터페이스 
- 자바 인터페이스를 사용하는 것은 `여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다`라고 이야기하는 것이다. 
- 구현을 변경하는 것은 쉽지만 인터페이스 자체를 바꾸기는 쉽지 않다.(구현하는 모든 클래스 수정 필요)

#### 추상 클래스 (abstract)
- 추상 클래스와 자바 인터페이스의 장단점은 인터페이스 수정의 용이성과 단일 클래스가 여러 인터페이스를 지원할 수 있는지 여부로 귀결된다.
- 최상위에 위치한 클래스를 인스턴스화해서 사용할 가능성이 있다면, 일반 클래스로 만들면 쓸데없는 추상화 계층을 제거할 수 있다. 

#### 버전 인터페이스 
- 인터페이스 확장한 인터페이스 추가하는 방식 (default 이후에는 사용되지 않을 듯..)

#### 값 객체
- 함수형 스타일 연산은 상태를 변화시키지 않으면 새로운 값을 생성하는 방식
- 상황이 변하는 경우 상태를 사용하여 변경가능한 객체를 사용하는 방식 

### 특화 
- 연산 간의 유사점, 차이점을 부각시키는 방향으로 코드를 작성하면 사용하고, 수정하기 쉬워진다. 

#### 하위 클래스 
- `이 객체는 상위클래스와 같다. 이 부분만 제외하면..` 이라 말하는 것과 같다. 
- 하위 클래스 문제점
  - 1 하위클래스를 사용하면 되돌리기가 쉽지않다.
  - 2 상위클래스를 먼저 이해해야 한다.
  - 3 상위클래스 수정이 위험해진다.
- 이러한 문제점을 인식하고 코딩을 하면 연산의 다양한 변형을 나타낼 수 있는 도구이다.

#### 구현자
- 연산내용이 변경되면 기존 메소드를 오버라이드해서 사용

#### 내부 클래스 
- 생성 클래스의 인스턴스와 완전히 분리된 내부 클래스를 사용하려면, 내부 클래스를 static 으로 선언해야 된다. 


### 인스턴스별 행위 
#### 조건문
- 단순한 인스턴스별 행동의 행태는 if/switch 구문을 이용하는 것이다. 
- 하위클래스나 위임으로 해결하는 방법이 더 좋다. 

#### 위임
- 각 인스턴스에서 다른 로직을 수행하도록 하는 다른 방법으로 위임이 있다. 
- 공통적으로 사용되는 로직은 위임 클래스를 참조하는 클래스에 있지만 변형은 여러 객체에 각각 구현된다. 

#### 플러그인 선택자 
- 한 두개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 안에 들어가도 좋은 경우 사용된다. 
- 메소드 이름을 필드에 저장해 두고 리플렉션을 통해 메소드를 호출하는 방식

```java
import java.lang.reflect.Method;

String name;

public void runTest() {
  Class[] noArgs = new Class[0];
  Method method = getClass().getMethod(name, noArgs);
  method.invoke(this, new Object[1]);
}

```
- 단 이방식은 비용이 상당하므로 일부 어려운 문제에만 제한적으로 사용하자

#### 익명 내부 클래스 
- 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드한 후, 지역적으로 사용하는 방식으로 이름이 필요없다. 

#### 라이브러리 클래스 
- 어떤 객체에도 적합하지 않안 기능을 구현하는 방식으로 빈 클래스에 정적 메소드를 구현하는 방식이다. 


## 06 상태 
- 효과적으로 상태를 관리하기 위한 키포인트는 유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리하는 것이다. 
- 상태가 유사한지 알 수 있는 두 개의 단서 
  - 1 두 개의 상태가 동일한 연산 안에서 사용되고
  - 2 동일한 시점에 생성되고 소멸되는가
  
## 접근
- 프로그래밍 언어는 저장된 값에 대한 접근과 계산으로 나눌 수 있다. 
- 메모리 접근은 현재 저장된 값을 반환하는 일종의 계산이다. 
- 계산은 아직 저장되지 않은 메모리 값을 읽는 일종의 값 접근이다. 

### 직접 접근 
- 직접 접근에 장점은 표현의 명확성이다. `x=10` 이 무엇을 뜻하는지는 너무나도 명확하다.
- 하지만 이런 명확성을 위해서는 유연성이 희생된다. 

```java
// 직접접근
doorRegister=1;

// 객체를 사용한 표현
door.open();
```

### 간접 접근 
- 메소드를 사용하는 입장에서는 저장되는 값을 직접 알 필요가 없다. 
- 따라서 기존 코드를 변경하지 않고 저장소 결정과 같은 문제를 변경할 수 있다. 

### 공용 상태 
- 여러 연산에서 같은 데이터 요소를 사용하는 경우 클래스에 필드를 선언해서 사용하는 것이 좋다. 
```java
class Point {
    int x, y;
}
```

### 가변 상태 
- 같은 객체에서도 인스턴스에 따라 각각 다른 데이터 요소를 필요로 할 때도 있다. (새로운 데이터 요소를 필요로 하는 것)
- 가변 상태는 데이터 요소의 이름을 키로 하고 값을 데이터로 하는 맵으로 표현된다.
```java
import java.util.HashMap;

class FlexibleObject {
  Map<String, Object> properties = new HashMap();
}
```
- 가능하다면 공융 상태를 사용하고, 경우에 따라 어떤 필드가 필요할지 확실치 않은 경우에만 가변 상태를 사용하라.

### 외재 상태 
- 프로그램의 일부에서만 객체의 특정 상태를 필요로 하는 경우가 있다. 
- 어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하는 것이 좋다. 
- 외재 상태를 사용하면 객체의 복사 및 디버깅이 어려워진다. 

## 변수 
- 변수를 범위에 따라 나누면 
  - 현재 범위에서만 접근 가능한 지역 변수
  - 같은 객체 내에서 접근 가능한 필드 변수
  - 같은 클래스의 어떤 객체에서도 접근 가능한 정적 변수
- 대부분의 경우 지역 변수를 사용하고 간간히 정적 변수(static), 전용 변수(private) 을 사용해서 객체 간의 의존성을 줄이는 것이 좋다. 
- 변수의 생명 기간은 가급적이면 변수의 범위에 가까워지도록 노력하는 것이 좋다. 

### 지역 변수
- 지역 변수는 변수가 선언된 지점이 속한 범위에서만 접근할 수 있다. 사용되기 직접에 가급적 최소 범위 내에서 선언해라.
- 지역 변수는 다음과 같은 역할을 한다
  - 컬렉터: 이후 사용을 위한 정보를 모은다. result(s) 로 짓는 것이 좋다. 
  - 카운터
  - 설명: 복잡한 표현을 해야 하는 경우, 표현 내용을 지역 변수에 저장
  - 재사용: 값이 바뀌지만 기존 값을 다시 사용해야 되는 경우.
  - 원소: 현재 사용하는 컬렉션의 원소를 저장하기 위해 사용 

### 필드 
- 필드의 범위와 생명기간은 필드를 갖고 있는 객체와 같다. 
  - 도우미: 객체의 여러 메소드에서 사용하는 객체를 저장한다. 여러 메소드에서 객체를 파라미터로 전달받는다면, 
  도우미 필드로 변경하고 생성자에서 필드를 설정하는 방법을 고려.
  - 플래그: 불린 플래그는 `객체가 두 가지 다른 방식으로 동작함`을 의미한다. 
  플래그에 따라 결정을 내리는 코드가 중복되어 있다면 전략 필드로 대체하는 것을 고려
  - 전략: 객체의 연산을 하는 다른 방법이 있음을 나타내는 경우 그 부분을 수행하는 객체를 필드에 저장하라.
  - 상태: 상태 필드는 스스로 다음 상태를 설정한다. 
  - 부속: 부속 필드는 해당 객체가 소유하는 객체나 데이터를 저장한다. 

### 파라미터 
- 하나의 객체에서 다른 객체에 대한 여러 메시지가 같은 파라미터를 필요로 한다면 그 파라미터를 호출되는 객체에 포함시키는 것이 나을 수 있다. 


### 수집 파라미터 
- 여러 메소드 호출을 통한 결과를 모으려면 결과를 통합하는 과정이 필요하다.
- 정수처럼 단순한 경우 메소드의 결과값을 반환하는 방법
- 복잡한 방식을 통해 결과를 통합해야 하는 경우 파라미터를 전달하는 방법이 직관적이다. 

### 옵션 파라미터 
- 어떤 메소드는 파라미터가 전달되지 않은 경우 기본 파라미터를 사용한다. 이경우 필수 파라미터를 앞에 둬야 한다. 
```java
public ServerSocket();
public ServerSocket(int port);
public ServerSocket(int port, int backlog);
```

### 가변 인자
- 임의의 수의 인자를 사용해서 메소드를 호출할 수 있다. 

### 파라미터 객체 
- 여러 개의 파라미터가 함께 여러 메소드로 전달된다면 이들을 묶어서 하나의 객체로 만드는 것을 고려할 수 있다. 

### 상수
- 변하지 않는 데이터를 프로그램의 여러 부분에서 사용해야 하는 경우 `static final`로 선언하고 그 변수를 참조하게 하라.

### 역할 제시형 작명
- 때로 단어를 축약해서 변수 이름을 짓는 경우 가독성의 희생하면서 타이핑에서 효율성을 택하는 것이다.

### 선언 타입
- Collection or List 의 선택존 일관성을 위해서 어느 정도 정확성과 일반성을 포기하는 것도 괜찮다.

## 초기화 
- 변수 초기화는 가급적 선언과 함께 하는 것이 좋다. (한 곳에서 변수에 대한 여러 정보를 얻을 수 있다.)
- 단 초기화에 드는 비용이 비싼 변수의 경우 생성과 초기화를 분리하는 것이 좋을 수 있다. 

### 열성적 초기화 
- 변수가 선언되거나 생성되자마자 초기화하는 방식으로 선언문이나 생성자에서 초기화하는 방식이다. 

### 게으른 초기화 
- 초기화 비용이 존재하거나 그 변수가 사용되지 않을 수도 있는경우 취득 메소드를 만들고 해당메소드가 처음 호출될 때 초기화 하는 방식

## 07 행위 
### 7.1 제어 흐름
- 자바의 경우 인접한 구문은 순서대로 수행된다. 처음 보는 독자들이 손쉽게 이해할 수 있게 하는 것이 좋다. 

### 7.2 주요 흐름 
- 프로그램의 주요 흐름을 명확히 표현하고, 애러 상황은 예외와 조건절을 사용해서 표현하면 된다. 

### 7.3 메시지
- 자바는 주로 메시지를 이용해서 로직을 표현한다. 메시지를 제어 흐름의 매커니즘으로 사용하면 상태의 변화가 중요해진다.
- 메시지 수신자가 메시지를 받으면, 발신자의 상태는 바뀌지 않지만 수신자의 상태는 바뀔 수 있다. 

### 7.4 선택 메시지
- 선택 메시지를 사용하면 명시적 조건문의 사용을 크게 줄일 수 있으며, 추후 확장이 쉽다.
```java
public void displayShape(Shape subject, Brush brush) {
    brush.display(subject);
}
```

### 7.5 더블 디스패치
- 두 가지의 독립ㅈ접인 차원에서는 변형을 표현하기 위해서는 2개의 선택 메시지를 직렬로 연결해야 한다. 
```java
displayShape(Shape subject, Brush brush) {
  subject.displayWith(brush);
}

Oval.displayWith(Brush brush) {
  brush.displayOval(this);
}

Rectangle.displayWith(Brush brush) {
  brush.displayRectangle(this);
}
```

### 7.6 분리 메시지
- 복잡한 연산은 밀접한 단위의 연산으로 나눈다.
- 여러 단계로 구성되는 복잡한 알고리즘의 경우 관련된 단계들을 모르고 이를 수행하기 위해 메시지를 보낼 수 있다. 
- 분리 메시지는 이름을 잘지어야 한다. 이름만으로 이후 단계에 어떤 일이 발생할지 짐작할 수 있어야 한다. 
- 메소드 객체 등의 패턴을 사용하여 프로그램 구조를 전달하는 편이 좋을 수 있다. 

### 7.7 되돌림 메시지
- 메시지를 같은 수신자에게 보내서 제어 흐름에 대칭성을 부여한다.
- 되돌림 메시지를 통해 호출되는 도우미 메소드는 그 자체로 중요하다. 


### 7.8 초청 메시지 
- 다른 방식으로 구현될 수 있는 메시지를 보내서 미래에 일어날 변형에 대비한다. 

### 7.9 설명 메시지
- 로직을 설명하기 위해 메시지를 보낸다. 
- 메시지를 사용하면 먼저 풀려는 문제의 이름을 반영하는 메시지를 보낸 후, 문제 푸는 방식을 반영하는 메시지를 보내서 명시할 수 있다. 

### 7.10 예외 흐름 
- 예외 흐름은 수행 빈도가 낮고 수정 빈도도 낮으며 개념적으로 덜 중요하므로, 주요 흐름은 명료하게 나타내고, 
 예외 흐름은 주요 흐름의 명료성을 훼손하지 않는 범위 내에서 명료하게 나타내라.  

### 7.11 보호절 
- 프로그램에는 주요 흐름이 있지만 떄로는 주요 흐름에서 벗어나야 할 때까 있다. 
- 보호절을 사용하면 간단한 지역적 예외 상황을 지역적인 변화만을 수반하며 표현할 수 있다. 

### 7.12 예외
- 예외는 여러 함수 호출을 걸쳐서 제어 흐름을 바꾸는 경우를 표현할 떄 유용하게 사용된다. 
- 예외를 발견한 쪽에서는 예외를 던지고, 예외를 처리하는 쪽이 예외를 받는 편이 그 사이의 모든 코드에서 예외를 체크하는 것보다 낫다

### 7.13 체크 예외
- 예외의 위험성 중 하나는 예외를 던졌을 때 아무도 그 예외를 받지 않을 수 있다는 것이다. (프로그램이 종료된다.)
- 체크예외를 넘겨받을 수 있는 클래스는 모두 그 예외를 받거나 다른 클래스로 넘겨줘야 한다.

### 7.14 예외 전달
- 하위 수준의 예외는 문제를 진단하는 데 유용한 정보를 제공해주는 경우가 많다. 
- 하위 수준 예외를 상위 수준 예외로 포장하라 (로그 출력)

## 08 메소드 
- 프로그램 로직을 여러 개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다. 
- 메소드를 클래스로 나누고, 클래스를 다시 패키지 단위로 나누면, 더 많은 정보를 전달하게 된다. 

### 조합메소드: 다른 메소드에 대한 호출로 메소드를 작성한다.
- 메소드 길이는 5-15줄 길이가 읽기 좋은 길이이다. 
- 일단 동작하는 코드를 만들고 구성방식에 대해 결정하라.

### 의도 제시형 이름: 메소드가 의도하는 바를 나타내는 이름을 사용한다.
- method 사용자는 method 이름을 통해 method 의 의도를 쉽게 파악할 수 있어야 한다.
- method 이름을 지을 때는 그 method 를 호출하는 입장해서 생각해서 method 를 호출하는 코드가 표현하려 하는 바에 도움을 줄 수 있도록 지어야 한다.

### 메소드 가시성: 메소드는 가급적 전용으로 한다.
- 네 가지 수준에 public, package, protect, private method 가시성 역시 의도를 전달할 수 있다. 
- 가시성을 선택할 때는 2가지 비용을 고려야 한다. 미래의 유연성과 객체를 사용하는 데 들어가는 비용이다. 


### 메소드 객체: 복잡한 메소드는 새로운 객체로 바꾼다.
- method 객체는 복잡하게 꼬여 있는 method를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다.
- method 객체 생성하는 순서
  - 1 method 이름을 따서 class 이름을 정한다.
  - 2 method 에서 사용하는 각 파라미터, 지역 변수, 필드에 대해 새로운 객체상의 필드를 생성한다.
  - 3 method 의 파라미터와 method 에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다.
  - 4 본래 method 를 새로운 class 의 calculate() 라는 method 로 복사한다.
  - 5 기존 method 의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다.
  - 6 본래 method 에서 필드를 설정하는 부분이 있다면, 다음과 같이 calculate() 가 반환된 후에 설정해준다.
```java
complexCalculation() {
    ComplexCalculator calculator = new ComplexCalculator();
    calculator.calculator();
}
```

### 오버라이드 메소드: 특화를 나타내기 위해 오버라이드를 사용한다.
- 상위 클래스에서 메소드를 abstract 로 선언했다면 이는 하위 클래스 연산을 특화하라는 뜻이고 final 메소드는 기존 연산을 변경할 수 없다는 뜻이다.
- super.method() 를 호출해서 상위 클래스 메소드를 사용할 수 있다. 

### 오버로드: 같은 연산에 대해 다른 인터페이스를 제공한다.
- 파라미터 타입만 다를 뿐, 같은 연산을 수행해야 한다.

### 메소드 반환 타입: 가급적 가장 일반적인 타입을 사용한다.
- 함수를 작성할 떄는 의도를 나타내는 반환 타입을 사용하라. 
- 가급적 메소드의 적용 범위를 넗히기 위해서 가장 추상적인 타입을 사용하라. (이후 구체적인 반환 클래스 타입을 유연하게 변경할 수 있다.)

### 메소드 주석: 코드 자체에서 쉽게 얻을 수 없는 정보는 주석을 통해 나타낸다.
- 프로그래머는 코드의 이름과 구조를 통해 최대한 많은 정보를 전달하는 것이 좋고, 코드만으로 분명하지 않은 경우에는 주석을 사용

### 도우미 메소드: 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용한다.
- helper method 는 당장 관련도가 떨어지는 세부 구현을 숨기고 이름을 통해 의도를 나타내어, 복잡하고 거대한 연산 코드를 읽기 좋게 하기 위함이다. 

### 디버그 출력 메소드: toString() 사용해서 유용한 디버그 관련 정보를 출력한다.

### 변환: 객체 형변환하는 메소드를 제공한다.
- 변환을 편리하게 표현하기 위해 새오운 의존성을 만드는 것은 바람직하지 않다.

### 변환 메소드: 원복 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다.
- 변환 메소드는 원본 객체를 다른 프로토콜을 사용하는 객체을 얻는 method 이다. 
- 의존성이 존재하지 않았는데 변환 메소드 때문에 의존성이 생기는 것을 주의하자 

### 변환 생성자: 대부분의 변환에 대해서는 원복 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다. 
- 변환 생성자는 원본 객체를 파라미터로 취해서 대상 객체를 반환한다.
- 여기도 역시 의존성 이슈가 존재하는데 이런 경우 생성자 팩토리 방식을 사용하자

### 생성: 객체 생성을 명확히 표현한다.
- 의미 있는 객체 생성을 위해서는 명확하고 직접적인 표현과 유연성 사이에서 균형을 잡아야 한다. 
- 생성과 관련된 구현 패턴을 이용하면, 객체 만들기를 더 잘 표현할 수 있다. 

### 완결 생성자: 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
- set 쓰지 말자 (왠만하면..)

### factory method: 좀더 복잡한 객체를 생성할 때, 생성자 대신 정적 메소드를 사용한다.
- 객체 생성을 나타내는 다른 방법은 클래스의 정적 메소드를 (static) 사용하는 것이다. 
- 정적 메소드는 추상타입을 반환할 수 있고, 별도의 이름을 가질 수 있다. 

### 내부 공장: 좀더 많은 설명이 필요하거나 이후 개선이 필요한 객체 생성의 경우 도우미 메소드를 캡슐화한다.

### 컬렉션 접근자 메서드: 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공한다.
- 컬렉션 객체의 경우 getXXX 를 제공시에는 주의 하자 (불변이나 객체 복사를 사용)
- 
### 불린 설정 메서드: 커뮤니케이션에 도움이 된다면 불린값을 설정하는 두개의 메소드를 제공한다.
- setValid(boolean valid) 보다 valid(), invalid() 두개의 메서드를 제공하자.

### 쿼리 메소드: isXXX 라는 이름으로 된 메소드를 사용해 불린 값을 반환한다.
- 객체의 상태를 알려주는 메서드 (is or have)

### 동등성 메소드: equals(), hashCode() 를 함께 정의한다.

### 취득 메소드: 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공한다.
- 무작정 취득 메소드를 제공하는 것 보다 가급적 필요한 로직을 데이터가 있는 쪽으로 옮겨보라

### 설정 메소드: 드물게, 메소드를 사용해서 필드 값을 설정한다.
- setXXX 보다 의도를 좀더 잘 드러낼 수 있는 있는 체계적인 인터페이스를 제공하는 것이 좋다. 


### 안전한 복사: 접근자 메소드를 통해 전달하거나 전달되는 인스턴스를 복사해서 앨리어스 문제를 회피한다.


## 09 컬렉션
### 9.1 메타포  
- 여러 값을 가진 변수로 여러 객체를 한번에 가리키는 역할을 하면서 컬렉션 자체도 객체로 취급된다. 

### 9.2 이슈 
- Collection 이 표현하는 첫번째 개념은 크기이다. 배열은 크기가 고정되지만 컬렉션은 변경할 수 있다. 
- Collection 이 표현하는 두번째 개념은 원소간의 순서가 의미가 있는 여부이다. 
- Collection 이 나타내는 다른 개념은 원소의 독자성이다. 

### 9.3 인터페이스 
#### 배열 
- 배열은 크기가 고정되어 있기에 단순한 연산의 경우 배열은 다른 컬렉션에 비해 시간 공간 모든 면에서 효율적이다.

#### Iterable 
- 어떤 변수를 Iterable 로 선언하는 것은 그 변수가 여러 개의 값을 갖고 있음을 뜻할 뿐이다. 

#### Collection 
- Collection은 Iterable를 상속하며, 원속 추가, 삭제, 검색, 크기 측정 등의 메소드를 지원한다.

#### List 
- List 는 Collection을 기반으로 원소 간에 정해진 순서를 부여한 것이다.

#### Set
- Set 은 중복 원소를 허용하지 않는 컬렉션으로 순서는 보장하지 않는다.

#### SortSet 
- 중복 원소를 허용하지는 않지만 원소간의 순서는 유지하는 인터페이스 

#### Map
- Map은 List 처럼 키를 사용하여 원소를 저장하지만 정수가 아닌 임의의 객체를 키로 사용할 수 있다. 


### 9.4 구현
- 일단 단순한 구현으로 시작한 후 경험에 따라 튜닝을 하는 것이 좋다.
- List: ArrayList 는 원소 접근이 빠르고 LinkedList 는 원소 추가와 제거가 빠르다.
- Set: HashSet 은 가장 빠르지만 순서를 보장하지 않고 LinkedHashSet 은 추가, 삭제에 시간이 더 걸린다.
- Map: HashMap 은 가장 빠르지만 순서를 보장하지 않고 LinkedHashMap 은 추가, 삭제에 시간이 더 걸린다.

### 9.4 Collections
- Collections는 다른 컬렉션 인터페이스에 넣기 적절치 않은 기능들을 모아놓은 유틸리티 클래스다.
- 검색 
  - indexOf() 는 연산에 걸리는 시간은 리스트 크기에 비례한다. 
  - 원소들이 정렬되어 있다면 이진 검색을 통해 효율적으로 인덱스를 구할 수 있다. (Collection.binarySearch(list, element))
- 정렬
  - reverse: 원소간의 순서를 거꾸로 변경
  - shuffle: 순서를 임의로 변경
  - sort: 오름 차순으로 원소를 정렬한다.
- 수정 불가능한 컬렉션 
  - 컬렉션을 수정하려 들 경우 예외를 발생시킬 수 있다. 
- 단일 원소 컬렉션 
- 무원소 컬렉션 

### 9.5 컬렉션 확장
- 컬렉션을 상속받아 확장할 수 있지만 그보다는 위임을 사용하는 편이 좋다. 

