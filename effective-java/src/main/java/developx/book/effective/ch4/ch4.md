## 4장 클래스와 인터페이스 
> 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내한다. 

### item 15 클래스와 멤버의 접근 권한을 최소화하라
- 잘 설계된 컴포넌트의 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는냐다.
- 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작방식에는 전혀 개의치 않는다.
- 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다. 

#### 접근 제어자 
- private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. 
- package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능 (default)
- protected: package-private 를 포함하면 하위 클래스에서 접근 가능
- public: 모든 곳에서 접근가능하다.

#### 주의할 내용 
- 상위 클래스의 메서드를 재정의할 떄는 그 접근 수준을 상위 클래스에서도다 좁게 설정할 수 없다.
- public 가변 필드를 가지는 클래스는 thread safe 하지 않다. 
- 길이가 0이 아닌 배열은 모두 변경가능하니 접근자 메서드를 제공해서는 안된다. (불변 리스트를 제공하거나, 복사본을 넘기자)

### item 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라 
- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수 없다. 
- package-private 클래스나, private 중첩 클래스에서는 종종 필드를 노출할 수 있다. 

### item 17 변경 가능성을 최소화 하라 
- 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다. 

#### 클래스를 불변으로 만드는 5가지 규칙
- 객체의 상태를 변경하는 메서드를 제공하지 않느다. 
- 클래스를 확장 할 수 없도록 한다. 
- 모든 필드를 final 로 선언한다. 
- 모든 필드를 private 으로 선언한다. 
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

### item 18 상속보다는 컴포지션을 사용하라 (여기서 상속이란 구현 상속 (extend class) 를 의미한다.)
- 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전하게 사용할 수 있다. 
- 구체 클래스의 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일을 위험하다.
- 상위 클래스의 변경에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 

#### 해결 방법
- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(구성) 이라 한다.

### item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라. 
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다. (@implSpec 태그 사용)
- 클래스 내부 동작과장 중간에 끼어들 수 있는 훅(hook)을 잘 선벽하여 protected 메서드 형태로 공객할 수 있어야 한다.
- 상속용으로 설계한 클래스는 배포전에 반드시 하위 클래스를 만들어 검증해야 한다. 
- 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다. 
  - 상위 클래스 생성자가 먼저 실행 되므로 하위 클래스에 재정의한 메서드가 생성자에서 초기화하는 값을 사용하는 경우 문제가 발생할 수 있다. 

### item 20 추상 클래스보다 인터페이스를 우선하라.
- 다중 구현용 타입으로는 인터페이스가 적합하다. 
- 복잡한 인터페이스라며 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법으로 고려하자. 
- 골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 한다. 
- 인터페이스에 걸려있는 구현상의 제약이 생긴다면 추상클래스로 골격을 제공하는 것으로 고려하자.

### item 21 인터페이스는 구현하는 쪽을 생각해 설계하라. 

### item 22 인터페이스는 타입을 정의하는 용도로만 사용하라. 
- 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공객용 수단으로 사용하지 말자

```java
public interface PhysicalConstants {
    static final double AVOGADROS_NUM = 6.022_140_857e23;
}
```
### item 23 태그 달린 클래스보다는 클래스 계층구조를 사용하라.
- 태그 달린 클래스를 써야 하는 상황의 거의 없다. 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각하자.

### item 24 멤버 클래스는 되도록 static 으로 만들라
- 중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다. 
- 중첩 클래스란 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 이외의 쓰임새가 있다면 톱클래스를 만들어야 한다. 
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static 을 붙여서 정적 멤버 클래스로 만들자.
- 비 정적 멤버 클래스의 경우 바깥 인스턴스로의 숨은 외부 참조를 가지게 된다. (GG 문제)

### item 25 톱 레벨 클래스는 한파일에 하나만 담으라 
- 소스 파일 하나에 톱레벨 클래스 여러개 선언하여도 자바 컴파일러는 불평하지 않는다.
- 하지만 이는 아무런 이득이 없고 심각한 위험을 감수해야 하는 행위다. 
- 컴파일러가 한 클래에 대한 정의를 여러개 만들어 내게 된다. 이는 소스 파일 컴파일 순서에 따라 동작이 달라질 수 있다. 



