# 2장 자바 메모리 영역과 메모리 오버플로
## 2.1 들어가며
- 메모리 관리 측면에서 C, C++ 개발자는 전권을 가진 황제인 동시에 잡다한 막노동도 직접하는 일꾼이라 할 수 있다. 
- 자바 개발자는 가상 머신이 제공하는 자동 메모리 관리 매커니즘 덕에 메모리 할당과 해제를 짝지어 코딩하지 않는다. 
- 하지만 통제권을 위임했기 떄문에 문제가 한번 터지면 가상 머신의 메모르 관리방식을 이해못하는 경우 해결하기 어렵다.

## 2.2 런타임 데이터 영역
### 2.2.1 프로그램 카운터 
- 현재 실행 중인 스레드의 바이트코드 줄 번호 표시기 역할을 하는 작은 메모리 영역이다. 
- 자바 가상 머신의 개념 모형에서 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다. 
- 프로그램의 제어 흐름, 분기, 순환, 점프 등의 표현하는 것으로 예외 처리나 스레드 복원 같은 기본 기능이 바로 이 표시기를 활용해 이루어진다.
- 멀티 스레딩 환경에서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. (스레드 프라이빗 메모리)

### 2.2.2 자바 가상 머신 스택
- 자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 운명을 같이 한다.(생성/삭제 시기 일치)
- 각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다.
- 지역변수 테이블에는 자바 가상 머신이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 
- StackOverflowError: 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 큰 경우 발생한다. 
- OutOfMemoryError: 스택 용량을 동적으로 확장하려고 할때 여유 메모리가 충분하지 않은 경우 발생한다. 

### 2.2.3 네이티브 메서드 스택
- 네이티브 메서드 스택은 자바 가상 머신 스택과 매우 비슷한 역할을 한다.
- 차이점은 자바 가상 머신 스택은 자바 메서드(바이트코드)를 실행할 때 사용하지만, 네이티브 메서드 스택은 네이티브 메서드를 실행시에 사용한다는 점이다. 
- StackOverflowError, OutOfMemoryError 는 동일하게 발생한다. 

### 2.2.4 자바 힙 
- 자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리이며, 모드 스레드가 공유하게 하며, 가상 머신이 구동될 때 만들어진다. 
- 이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것이며, 거의 모든 객체 인스턴스가 이 영역에 할당된다. 
- 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 GC 힙이라고도 한다. 
- OutOfMemoryError: 새로운 인스턴스에 할당해 줄 힙 공간이 부족하고 힙을 더는 확장할 수 없는 경우 발생한다. 

### 2.2.5 메서드 영역
- 메서드 영역도 자바 힙처럼 모든 스레드가 공유된다.
- 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 개시등을 저장한다.

### 2.2.6 런타임 상수 풀
- 런타임 상수 풀은 메서드 영역의 일부다. 
- 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
- 런타임 상수 풀의 중요한 특징은 바로 동적이라는 점이다. 
  - 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 게 아니다. 
  - 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가 될 수 있다.

```java
public class Intern {
  public static void main(String[] args) {
    String a = "apple";
    String b = new String("apple");

    String c = b.intern();

    System.out.println("(a==b) = " + (a == b)); // false
    System.out.println("(a==c) = " + (a == c)); // true
  }
}
}
```

### 2.2.7 다이렉트 메모리
- JDK 1.4 에서 NIO가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개 되었다. 
- NIO 는 힙이 아닌 메모리를 직접 할당 할 수 있는 네이티브 함수 라이브러를 사용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다. 
- 물리 메모리에 직접 할당하기 때문에, 자바 힙 크기의 제약과는 무관하지만, 이 역시 메모리라는 사실은 변함이 없다. 
- 따라서 하부 기기의 총 메모리 용량과 프로세서가 다룰 수 있는 주소공간을 넘어서게 되면 OutOfMemoryError 이 발생하게 된다.

## 2.3 핫스팟 가상 머신에서의 객체 들여다보기
- 핫스팟이 관리하는 자바 힙에서의 객체 생성, 레이아웃, 접근방법 등의 상세내용을 알아본다. 

### 2.3.1 객체 생성
- 자바 프로그램이 동작하는 동안 언제든 수시로 객체가 만들어진다. (new 키워드)
- 자바 가상 머신이 new 명령에 해당하는 바이트 코드를 만나면...
  - 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.
  - 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인한다.
  - 준비 되지 않는 클래스라면 로딩부터 해야 한다. 
  - 로딩이 완료되면, 새 객체를 담을 메모리를 할당한다. (이는 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라 할 수 있다.)
  - 멀티스레딩 환경에서 메모리 할당 동기화 방법
    - 1 메모리 할당을 동기화로 CAS 를 통해 원자적으로 수행 
    - 2 스레드마다 스레드 로컬 할당 버퍼(TLAB) 메모리를 할당하여 이를 사용하게 하는 방식
    - 가상 머신이 로컬 할당 버퍼를 사용할 지는 -XX:+/-UseTLAB 매개변수로 설정한다.
  - 각 개체에 필요한 설정을 해준다. 
    - 어느 클래스의 인스턴스인지, 클래스의 메타 정보는 어떻게 찾는지, 이객체의 해시 코드는 무엇인지, GC 세대 나이는 얼마인지
- 