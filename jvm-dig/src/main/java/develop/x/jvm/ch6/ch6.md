# 6장 클래스 파일 구조
## 6.1 들어가며
- 컴퓨터는 0,1 만 인식할 수 있다. 그렇기에 작성한 프로그램이 동작하려면 먼저 컴파일러를 실행해서 0과 1로 구성된 바이너리 형식으로 변환해야 된다. 

## 6.2 플랫폼 독립을 향한 초석
- 자바 탄생 시 내건 구호인 `한 번 작성하면 어디서든 실행된다`에는 여러 플랫폼의 경계를 허물고자 하는 소프트웨어이다. 
- 자바 가상 머신이 다양한 플랫폼을 지원하고, 모든 가상 머신이 동일한 프로그램 저장형식(바이트코드)을 지원한다는 점이 플랫폼 독립성의 핵심이다. 
- 자바 가상 머신에서 동작하는 소스는 코틀린, 클로저, 그루비, JRuby, JPython 등이 있다. 

## 6.3 클래스 파일의 구조
- 모든 클래스 파일은 각각 하나의 클래스 또는 인터페이스를 정의한다. 반면 클래스나 인터페이스를 꼭 파일에 담아 둘 필요는 없다. 
- 클래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체다. 각 데이터 항목이 정해진 순서에 맞게 구분 기호 없이 나열된다. 
- 클래스 파일에 데이터를 저장하는 뎅는 의사구조를 사용하는데 여기에는 두 가지 데이터만 존재한다. 
  - 부호 없는 숫자: 기본 데이터 타입을 표현한다. u1, u2, u4, u8 은 각각 1바이트, 2바이트, 4바이트, 8바이트를 뜻한다. 
  - 테이블: 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 표현한다. 이름은 관례적으로 _info 로 끝난다.
  - 같은 타입의 데이터 여러 개를 표현할 때 그 개수 알려주는 타입이 바로 앞에 존재한다. (*_count 형태) 

### 6.3.1 매직 넘버와 클래스 파일의 버전
- 모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작한다. 
- 매직 넘버는 가상 머신이 허용하는 클래스 파일인지 여부를 확인하는데만 사용한다. 
- 매직 넘버 다음 4바이트는 클래스 파일의 버전 번호이다. 2자리는 마이너 버전 다음 2자리는 메이저 버전을 뜻한다. 
- 상위 버전 JDK는 하위 버전을 인식할 수 있지만 하위 버전 JDK는 상위 버전의 클래스 파일을 실행할 수 없다. 


### 6.3.2 상수 풀 
- 상수 풀은 클래스 파일의 자원 창고라 할 수 있다. 다른 클래스와 가장 많이 연관되며, 사이도 대체로 가장 크다.
- 상수 풀에 담기는 상수 유형은 리터럴과 심벌 참조 두 가지이다. 
- 리터럴은 자바 언어 수준에서 이야기하는 상수(final 로 선언된 문자열이나 상수)
- 심벌 참조는 컴파일에 관련된 개념으로 다음 유형의 상수들이 포함된다. 
  - 모듈에서 익스포트하거나 임포트하는 패키지
  - 클래스와 인터페이스의 완전한 이름
  - 필드 이름과 서술자
  - 메서드 이름과 서술자
  - 메서드 핸들과 매서드 타입
  - 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수 
- 상수 풀 안의 상수 각각이 모두 테이블이다. JDK 21 기준으로 총 17가지 상수 타입이 존재한다. 

### 6.3.3 접근 플래그 
- 다음 2바이트는 현재 클래스(인터페이스)의 접근 정보를 식별하는 접근 플래그이다. 
- 현재 클래스 파일이 표현하는 대상이 클래스인지 인터페이스인지 public, abstract, final 등의 정보가 담긴다. 

### 6.3.4 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스 
- 현재 클래스의 인덱스와 부모 클래스 인덱스, 인터페이스 인덱스 컬렉션이 나온다. 
- 클래스 파일의 상속관게를 규정하게 된다. 

### 6.3.5 필드 테이블 
- 클래스안에 선언된 변수들을 설명하는 사용된다 클래스 변수와 인스턴스 변수를 뜻한다. 
  - 접근 제어자(public, private, protected)
  - 인스턴스 변수 (static)
  - 불변 여부(final)
  - 휘발성 (volatile)
  - 직렬화시 포함여부(transient)
  - 데이터 타입 (기본 타입, 객체, 배열)
  - 필드 이름

### 6.3.6 메서드 테이블 
- 클래스안에 정의된 메서드를 설명하는 것에 사용된다. 
  - 접근 제어자(public, private, protected)
  - static 메서드
  - final 메서드
  - synchronized 메서드
  - abstract 메서드 
  
### 6.3.7 속성 테이블 
- 클래스 파일, 필드테이블, 메서드 테이블 code 속성, 레코드 구성요소는 모두 특정 시나리오에서 특정한 정보를 설명하기 위해 고유한 속성 테이블을 포함할 수있다. 

#### 6.3.7.1 code 속성 
- 메서드 본문 코드는 자바 컴파일러에 의해 최종적으로 바이트코드 명령어로 변환된 후 Code 속성에 저장된다. 

#### 6.3.7.2 Exceptions 속성 
- Exceptions 속성은 메서드에서 throw 될 수 있는 검사 예외, 즉 메서드 설명에서 throws 키워드 뒤에 나오는 예외들을 나열하는 기능을 한다. 

#### 6.3.7.3 LineNumberTable 속성
- 소스 코드의 줄 번호와 바이트 코드의 줄 번호 사이의 대응 관계를 설명하는 속성이다. 
- 없는 경우 예외가 발생했을 때 오류를 일으킨 코드의 줄 번호가 스택 추적 정보에 나타나지 않는다. 

#### 6.3.7.4 LocalVariableTable 과 LocalVariableTypeTable 
- LocalVariableTable 은 스택 프레임에 있는 지역 변수 테이블 안의 변수와 자바 소스 코드에 정의된 변수 사이의 관계를 설명하는 속성이다. 
- 이 속성을 생성하지 않으면 이 메서드를 참조시 매개 변수 이름 대신 arg0 이라는 변수명을 가지게 된다. 
- 제너릭이 도입되면서 LocalVariableTypeTable 이 추가되었다. 

#### 6.3.7.5 sourceFile 과 SourceDebugExtension 속성
- SourceFile 속성에는 클래스 파일을 생성한 자바 소스 파일 이름이 기록된다. 
- SourceDebugExtension 는 동적으로 생성된 클래스에 개발자를 위한 사용자 정의 정보를 쉽게 추가할 수 있도록 설계된 속성이다. 

#### 6.3.7.6 ConstantValue 속성 
- 정적 변수에 값을 자동으로 할당하도록 가상 머신에 알린다. 
- static 키워드로 선언된 변수(클래스 변수)에만 이 속성이 붙는다. 

#### 6.3.7.7 InnerClasses 속성
- 내부 클래스와 호스트 클래스 사이의 연결 관계를 기록한다. 

#### 6.3.7.8 Deprecated 와 Synthetic 속성
- Deprecated 속성은 클래스, 필드 또는 메서드를 프로그램 작성자가 폐기 대상으로 지정
- Synthetic 속성은 컴파일러가 추가한 필드나 메서드를 나타낸다. 

#### 6.3.7.9 StackMapTable 속성
- 가상 머신이 클래스 로드할 때 바이트코드 검증 단계에서 타입 검증기가 활용된다. 

#### 6.3.7.10 Signature 속성
- 제너릭을 지원하기 위해 추가된 속성으로 속성 테이블, 필드 테이블, 메서서드 테이블에 선택적으로 등장한다.

#### 6.3.7.11 BootstrapMethod 속성
- 복잡한 가변 길이 속성으로 클래스 파일의 속성 테이블에 위치한다. 

#### 6.3.7.12 MethodParameters 속성
- 메서드 테이블에서 사용되는 가변 길이 속성으로, 메서드가 받는 매개 변수의 각각의 이름과 정보를 기록한다. 

#### 6.3.7.13 모듈화 관련 속성
- JDK 9에서 모듈 도입되면서 모듈과 관련된 정보를 담는다.

#### 6.3.7.14 런타임 애너테이션 관련 속성
- 애너테이션 정보를 담는다.

#### 6.3.7.15 Record 속성
#### 6.3.7.16 PermittedSubClasses 속성


## 6.4 바이트코드 명령어 소개
- 자바 가상 머신의 명령어는 특정 작업을 뜻하는 바이트 길이의 숫자인 연산 코드(opcode) 와 해당하는 작업에 필요한 0개의 피연산자로 구성된다.

### 6.4.1 바이트코드와 데이터 타입들
- 명령어 집합을 보면 대다수 명령어 자체에 해당 연산에 필요한 데이터 타입 정보가 들어가 있다. 
  - iload 명령어는 지역 변수 테이블에서 피연산자 스택으로 int 타입 데이터를 읽어드린다. 
  - fload 명령어는 지역 변수 테이블에서 피연산자 스택으로 float 타입 데이터를 읽어드린다.
- 단 byte, char, short, boolean 타입은 int 연산자를 이용해서 처리한다.

### 6.4.2 로드와 스토어 명령어
- 로드와 스토어 명령어는 스택 프레임의 지역 변수 테이블과 피연산 스택 사이에서 데이터를 주고 받는 데 쓰인다. 
- 지역변수를 피연산자 스택으로 읽어오기 (iload)
- 피연산자 스택의 값을 지역 변수 테이블에 저장하기 (istore)
- 상수를 피연산자 스택으로 읽어오기 (bipush)
- 더 넒은 인덱스를 사용하여 더 많은 지역 변수에 접근하거나 더 큰 피연산자에 접근하기 (wide)

### 6.4.3 산술 명령어
- 피연산자 스택의 값 두개를 이용해 특정한 산술 연산을 수행한다. 결과값을 다시 피연산자 스택의 맨 위에 저장한다. 
  - 더하기: iadd
  - 빼기: isub
  - 곱하기: imul
  - 나누기: idiv
  - 나머지: irem
  - 부장: ineg
  - 시프트: ishl..
  - 비트 OR: ior
  - 비트 AND: iand
  - 지역 변숫값 증가: iinc
  - 비교: dcmpg, fcmpg

### 6.4.4 형변환 명령어 
- 숫자 타입 데이터를 다른 숫자 타입으로 변환하는 명령어로 따로 명령어을 명시하지 않아도 자바 가상 머신이 알아서 수행한다. 
- 단 범위가 축소될 때는 반드시 명령어를 명시해야 한다. (i2s, l2i, f2i, f2l)

### 6.4.5 객체 생성과 접근 명령어
- 클래스 생성: new
- 배열 생성: newarray, anewarry, mutianewaaray
- 클래스 필드와 인스턴스 필드 접근: getfield, putfield, getstatic, putstatic
- 배열원소를 피연산로 읽어오기: baload, caload, saload, iaload, laload
- 피연산자 스택의 값을 배열원소에 저장, bastors, castors, sastors, iastors
- 배열 길이: arraylength
- 타입 확인: instanceof, checkcast (배열)

### 6.4.6 피연산자 스택 관리 명령어
- 피연산자 스택에서 최상위 원소 1,2 꺼내기: pop, pop2
- 스택의 최상위 값 1,2 개를 복제한 다음 스택 최상위에 다시 넣기 : dup, dup2
- 스택의 최상에 있는 값 두개를 치환: swap

### 6.4.7 제어 전이 명령어
- 프로그램의 실행 흐름을 조건에 따라 또는 무조건적으로 지정한 위치의 명령어로 이동시킨다. 
  - 조건 분기: ifet, ifit, ifle, ifne
  - 복합 조건 분기: tableswitch, lookupswitch
  - 무조건 분기: goto, jsr

### 6.4.8 메서드 호출과 반환 명령어
- invokevirtual: 객체의 인스턴스 메서드를 호출한다.
- invokeinterface: 인터페이스 메서드를 호출한다.
- invokespecial: 인스턴스 초기화 메서드, private 메서드, 부모 클래스의 메서드를 포함하여 특수 처리가 필요한 인스턴스 메서드를 호출한다. 
- invokestatic: static 메서드를 호출한다. 
- invokedynamic: 런타임 호출 사이트 한정자가 참조하는 메서드를 동적으로 찾아 호출한다. 

### 6.4.9 예외 처리 명령어
자바 프로그램에서 예외를 명시적으로 던지는 작업은 athrow 명령어로 구현된다. 


### 6.4.10 동기화 명령어
- 자바 가상 머신은 메서드 수준 동기화와 블록 동기화를 지원하게 된다. 
- 메서드 수준 동기화는 바이트코드 명령어가 아니라 메서드 호출과 반환 명령어로 구현된다. 
- 블록 동기화는 monitorexit, monitorenter 로 구성된다. 

## 6.5 설계는 공개, 구현은 미공개
- `자바 가상 머신 명세`는 공통된 프로그램 저장 형식(클래스 파일 형식과 바이트코드 명령어 집합)을 정의하고 있다. 
- 하지만 어떻게 구현했느냐는 공개되지 않을 수 있음을 이해해야 한다. 고성능, 적은 메모리 소비, 이식성등을 고려해서 가상 머신을 구현할 수 있다. 
