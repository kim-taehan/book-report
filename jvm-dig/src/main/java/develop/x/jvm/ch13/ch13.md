# 13장 스레드 안정성과 락 최적화 

## 13.1 들어가며
- 소프트웨어 산업 초기에는 알고리즘이 프로그래밍의 중심이었다. 개발자는 데이터와 절차를 구분해 생각했다. 
- 객체 지향 프로그래밍은 개발 효율을 높이고 규모가 훨씬 큰 소프트웨어를 구축할 수 있는 길을 열었다. 
- 좋은 설계 원칙이라도 떄로는 현실과 타협해야 한다. 프로그램이 컴퓨터에서 올바르게 실행되는지 확인하는 것이 먼저다
- 더 빨리 실행되도록 ㅎ최적화 하는 일은 그 후에 고민해야 한다. 

## 13.2 스레드 안정성
- 여러 스레드가 한 객체에 동시에 접근할 떄, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서 객체를 호출하는 
행위가 올바른 결과를 얻을 수 있다면, 그 객체는 스레드 안전하다 라고 할 수 있다. 
  - 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요없다.
  - 추가적인 동기화 수단이나 호출자 특에서 조율이 필요 없다. 

### 13.2.1 자바 언어의 스레드 안정성
- 스레드가 하나이거나 다른 스레드와 데이터를 공유하지 않는다면, 프로그램이 순차적으로 실행되든 여러 스레드가 동시에 실행되든
스레드 안정성 관점에서는 차이가 없다. 
- 자바 언어에서는 공유 데이터의 안전한 정도를 다음과 같이 5 단계로 나눌 수 있다. 
  - 불변
  - 절대적 스레드 안정
  - 조건부 스레드 안정
  - 스레드 호환
  - 스레드 적대적

#### 13.2.1.1 불변 
- 불변 객체는 객체 자체의 메서드 구현과 호출자 모두에서 아무런 안전장치 없이도 스레드 안전하다.
- `불변성`이 선사하는 안정성은 가장 직접적이고 완전무결하다. (java.lang.String 객체)

#### 13.2.1.2 절대적 스레드 안전
- 어떤 런타임 환경에서든 호출자가 추가적인 동기화 조치를 할 필요 없다. 
- `java.util.Vector`는 add(), get(), size() 등의 모든 메서드가 synchronized 메서드이므로 효울적이지 않지만 원자성, 가시성, 실행순서를 보장한다. 
- 하지만 모든 메서드에 synchronized 가 붙어 있어도 호출자가 추가로 동기화할 필요가 절대로 없다는 뜻은 아니다.
```java
public class VectorTest_1 {

    private static Vector<Integer> vector = new Vector<>();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 10; i++) {
                vector.add(i);
            }

            new Thread(() -> {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                        vector.remove(i);
                    }
                }
            }).start();

            new Thread(() -> {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                        System.out.println("vector = " + vector.get(i));
                    }
                }
            }).start();

            while (Thread.activeCount() > 20) ;
        }
    }
}
```

#### 13.2.1.3 조건부 스레드 안전
- 조건부 스레드 안전은 우리가 일반적으로 `스레드 안전하다` 라고 말할 때는 안전 수준을 말한다.
- 조건부 스레드 안전한 객체는 단일한 작업을 별도 보호 조치 없이 스레드로부터 안전하게 수행한다. 
- 하지만 특정 순서로 연달아 호출하는 상황에서도 정확성을 보장하려면 호출자에게 추가로 동기화해야 할 수 있다.
- Vector, HashTable 등이 포함

#### 13.2.1.4 스레드 호환
- 객체 자체는 스레드로부터 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 환경에서도 안전하게 사용할 수 있다. 
- ArrayList, HashMap 등이 포함

#### 13.2.1.5 스레드 적대적 
- 호출자가 동기화 조치를 취하더라도 멀티스레드 환경에서 안전하게 사용할 수 없다는 뜻이다. 


### 13.2.2 스레드 안전성 구현 
- 스레드 안정성을 구현하는 코드 작성법과 가상 머신의 동기화와 락을 설명한다. 

#### 13.2.2.1 상호 배제 동기화 
- 