# 13장 스레드 안정성과 락 최적화 

## 13.1 들어가며
- 소프트웨어 산업 초기에는 알고리즘이 프로그래밍의 중심이었다. 개발자는 데이터와 절차를 구분해 생각했다. 
- 객체 지향 프로그래밍은 개발 효율을 높이고 규모가 훨씬 큰 소프트웨어를 구축할 수 있는 길을 열었다. 
- 좋은 설계 원칙이라도 떄로는 현실과 타협해야 한다. 프로그램이 컴퓨터에서 올바르게 실행되는지 확인하는 것이 먼저다
- 더 빨리 실행되도록 ㅎ최적화 하는 일은 그 후에 고민해야 한다. 

## 13.2 스레드 안정성
- 여러 스레드가 한 객체에 동시에 접근할 떄, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서 객체를 호출하는 
행위가 올바른 결과를 얻을 수 있다면, 그 객체는 스레드 안전하다 라고 할 수 있다. 
  - 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요없다.
  - 추가적인 동기화 수단이나 호출자 특에서 조율이 필요 없다. 

### 13.2.1 자바 언어의 스레드 안정성
- 스레드가 하나이거나 다른 스레드와 데이터를 공유하지 않는다면, 프로그램이 순차적으로 실행되든 여러 스레드가 동시에 실행되든
스레드 안정성 관점에서는 차이가 없다. 
- 자바 언어에서는 공유 데이터의 안전한 정도를 다음과 같이 5 단계로 나눌 수 있다. 
  - 불변
  - 절대적 스레드 안정
  - 조건부 스레드 안정
  - 스레드 호환
  - 스레드 적대적

#### 13.2.1.1 불변 
- 불변 객체는 객체 자체의 메서드 구현과 호출자 모두에서 아무런 안전장치 없이도 스레드 안전하다.
- `불변성`이 선사하는 안정성은 가장 직접적이고 완전무결하다. (java.lang.String 객체)

#### 13.2.1.2 절대적 스레드 안전
- 어떤 런타임 환경에서든 호출자가 추가적인 동기화 조치를 할 필요 없다. 
- `java.util.Vector`는 add(), get(), size() 등의 모든 메서드가 synchronized 메서드이므로 효울적이지 않지만 원자성, 가시성, 실행순서를 보장한다. 
- 하지만 모든 메서드에 synchronized 가 붙어 있어도 호출자가 추가로 동기화할 필요가 절대로 없다는 뜻은 아니다.
```java
public class VectorTest_1 {

    private static Vector<Integer> vector = new Vector<>();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 10; i++) {
                vector.add(i);
            }

            new Thread(() -> {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                        vector.remove(i);
                    }
                }
            }).start();

            new Thread(() -> {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                        System.out.println("vector = " + vector.get(i));
                    }
                }
            }).start();

            while (Thread.activeCount() > 20) ;
        }
    }
}
```

#### 13.2.1.3 조건부 스레드 안전
- 조건부 스레드 안전은 우리가 일반적으로 `스레드 안전하다` 라고 말할 때는 안전 수준을 말한다.
- 조건부 스레드 안전한 객체는 단일한 작업을 별도 보호 조치 없이 스레드로부터 안전하게 수행한다. 
- 하지만 특정 순서로 연달아 호출하는 상황에서도 정확성을 보장하려면 호출자에게 추가로 동기화해야 할 수 있다.
- Vector, HashTable 등이 포함

#### 13.2.1.4 스레드 호환
- 객체 자체는 스레드로부터 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 환경에서도 안전하게 사용할 수 있다. 
- ArrayList, HashMap 등이 포함

#### 13.2.1.5 스레드 적대적 
- 호출자가 동기화 조치를 취하더라도 멀티스레드 환경에서 안전하게 사용할 수 없다는 뜻이다. 


### 13.2.2 스레드 안전성 구현 
- 스레드 안정성을 구현하는 코드 작성법과 가상 머신의 동기화와 락을 설명한다. 

#### 13.2.2.1 상호 배제 동기화 
- 상호 배제 동기화는 가장 일반적이면서 가장 중요한 동시성 보장 수단이다. 
- 동기화란 공유 데이터에 여러 스레드가 접근하려는 상황에서 그 어떤 시점에서든 단 하나의 스레드만 데이터를 사용할 수 있다는 뜻이다. 
- 자바에서 상호 배제 동기화의 가장 기본적인 수단은 코드 불록을 동기화하는 synchronized 키워드이다.
  - synchronized 를 컴파일하면 monitorenter 와 monitorexit 라는 두가지 바이이트코드 명령어가 생성되며, 동기화 블록 전후에 실행된다. 
  - monitorenter 명령어를 실행할 때는 먼저 객체의 락을 얻으려 시도하며, 이떄 객체가 잠겨 있지 않거나 현재 스레드가 락을 이미 소유하고 있다면 값을 1씩 증가시킨다. 
  - monitorexit 명령어를 실행할 때 1씩 감소시킨다. 그리고 0이 되면 락이 해제 된다. 
- 락을 소유한다는 건 실행 비용 측면에서 상당이 무거운 작업이다. 스레드는 정지하거나 깨우려면 운영 체제의 도움을 얻어야 한다.
- jdk 5부터는 `java.util.concurrent` 패키지가 자바 클래스에 추가되었고, Lock 인터페이스가 새로운 상호 배제 동기화를 제공한다. 
- ReentrantLock 이 Lock 인터페이스를 구현한 대표적인 클래스이다. 기본적인 사용법은 synchronized 와 비슷하지만 몇 가지 진보된 기능을 제공한다. 
  - 대기 중 인터럽트: 락을 소유한 스레드가 오랜 시간 락을 해제하지 않을 때 같은 락을 얻기 위해 대기중인 스레드가 락을 포기할 수 있다. 
  - 페어 락: 락 획득을 시도한 시간 순서대로 락을 얻는다. (단 성능이 떨어져서 처리향에 악영향을 줄 수 있다.)
  - 둘 이상 조건 지정: 동시에 여러 개의 Condition 객체와 연결 지을 수 있다. 
- JDK 6 이후에는 synchronized, ReentrantLock 을 선택시에 성능은 고려대상이 아니다. 
- 필자가 synchronized 권장하는 이유
  - synchronized 는 자바 구문 수준의 동기화이며 매우 명확하고 간결하다. 
  - Lock 은 finally 블록에서 해제해야 한다. 그렇지 않으면 예외 발생시 락이 해제되지 않을 수 있다.  
  - 동기화 최적화는 자바 가상 머신에 맡기는게 유리하다. synchronized 를 사용하면 자바 가상 머신이 스레드 및 락 관련 내부정보를 사용할 수 있다. 

#### 13.2.2.2 논블로킹 동기화 
- 상호 배제 동기화의 큰 문제는 스레드 일시 정지와 꺠우기가 초래하는 성능 저하다. 이런 동기화를 블로킹 동기화라고 한다. 
- 상호 배제 동기화는 비관적 동시성 전략에 속한다. 반드시 문제가 생길 것이라 가정하고 락을 걸게 된다. 
- 락프리 프로그래밍: 낙관적 동시성 전략으로 일단 작업을 시작 후 충돌이 발생하면 보완 조치를 취하는 방식이다. 
- JDK 5 부터 자바 클래스 라이브러리도 CAS 연산을 사용하기 시작했다. `sun.misc.Unsafe` 클래스의 compareAndSwapInt()와 compareAndSwapLong() 메서드 이다. 

#### 13.2.2.3 동기화가 필요 없는 매커니즘 
- 공유 데이터를 전혀 사용하지 않는 메서드라면 정확성을 보장해야 할 대상이 없으니 자연스럽게 동기화가 필요없다. 
  - 재진입 코드: 전역변수 힙에 저장된 데이터 공유 시스템 자원을 사용하지 않고 모든 정보를 매개변수로 받는다. 재진입이 불가능한 다른 메서드를 호출하지 않는다. 
  - 스레드 로컬 저장소:

## 13.3 락 최적화 
- JDK 6에서는 동시성 효율이 크게 개선되었다. 적응형 스핀, 락 제거, 락 범위 확장, 경량 락, 편향 락 등의 락 최적화 기술을 구현하였다. 

### 13.3.1 스핀 락과 적응형 스핀
- 수많은 애플리케이션이 공유 데이터를 아주 잠깐만 잠갔다가 곧바로 해제한다는 사실을 알게 됐다. (여기서 시작된 내용으로)
- 스레드를 멈추지 않고 루프를 돌게하는 방식으로 락을 관리한다.
- 만약 락이 잠시만 잠겨 있을 때는 효과가 좋다. 반대로 장시간 잠겨 있다면 그저 루프만 돌면서 프로세스 자원을 낭비하게 된다. 

### 13.3.2 락 제거
- 락 제거는 특정 코드 조각에서 런타임에 데이터 경합이 일어나지 않는다고 판단되면 가상 머신의 JIT 컴파일러가 해당 락을 제거하는 최적화 기법이다. 

### 13.3.3 락 범위 확장 
- 코드를 작성할 때는 동기화 블록의 범위를 가능한 좁게 줄이는 게 좋다. 데이터가 실제로 공유되는 범위에 딱 맞추는 것이다. 
- 이 경우 대부분의 경우 옳지만 연이은 다수의 작이나 순환문에서 똑같은 락 객체를 반복해서 잠그고 해제하는 상황의 경우 의미 없이 성능만 떨어뜨릴 것이다. 

### 13.3.4 경량 락 
- 경략 락이란 운영 체제의 뮤텍스를 사용해 구현한 기존 락보다 가볍다는 뜻이다. 

### 13.3.5 편향 락 
- 편향 락은 경합이 없을 때 데이터의 동기화 장치들을 제거하여 프로그램 실행 성능을 높이는 최적화 기법이다. 
- 경향락은 CA 연산을 써서 뮤텍스 사용을 피했다. 편향 락은 한 걸음 더 나아가 CAS 연산조차 쓰지 않게 하여 전체 동기화를 없앤다. 
