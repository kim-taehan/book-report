# 12장 자바 메모리 모델과 스레드
## 12.1 들어가며
- 컴퓨터 연산 성능과 저장/통신 성능(디스크 I/O, 네트워크 통신, 데이터베이스 접근)의 격차가 너무 크기 때문이다. 
- 프로세서가 요청한 자원을 기다리며 대부분의 시간을 빈둥거리지 않게 하려면, 그 시간에 무언가 다른 일을 시킬 방법을 찾아야 한다. 
- 서버는 프로세서 성능을 최대한 활용하는 것 외에도, 서비스를 여러 클라이언트에 동시에 제공해야 한다. 
- 서비스의 중요한 성능 지표인 초당 트랜잭션(TPS)은 서버가 1초에 응답할 수 있는 요청 수의 평균이다. 
- 이장에서는 가상 머신이 멀티스레딩을 구현하는 방법과 스레드들이 데이터를 공유하거나 데이터를 놓고 경합하며 발생하는 다양한 문제와 그 해결책을 선보일 것이다. 

## 12.2 하드웨어에서의 효율과 일관성
- 물리적인 컴퓨터의 동시성 문제는 가상 머신의 동시성 문제와 비슷한 점이 많다. 
- 컴퓨팅 작업이 단순히 프로세서의 컴퓨팅(연산) 만으로 이루어질 수 없다. 프로세서는 데이터를 읽고 결과를 저장한는 메모리 I/O는 없애기가 어렵다. 
- 그런데 메모리는 프로세서에 비해 속도가 느리기에 현대적인 컴퓨터에서는 둘 사이에 (캐시) 계층을 하나 이상 두게 된다. 
- 필요한 데이터를 캐시에 복사해 두어 작업을 빠르게 수행하고, 작업이 완료되면 캐시에서 메모리로 동기화하여 프로세서는 메모리 I/O를 기다릴 필요가 없어진다.
- 하지만 멀티프로세서 시스템에서는 프로세서 각각이 자신만이 캐시를 갖춘 채 동일한 메인 메모리를 공유하면서 캐시 일관성이라는 새로운 문제가 생길 수 있다. 
- 캐시 일관성 문제를 해결하려면 프로세서가 캐시를 이용할 떄 정해진 프로토콜을 따라야 한다. (MSI, MESI, MOSI, 시냅스, Firefly, Dragon protocol) 
- 비순차 실행 최적화는 명령어를 실행하는 순서가 입력 코드에 기술된 순서와 다르게 동작하여 컴퓨팅 능력을 끌어내는 기술이다. 

## 12.3 자바 메모리 모델 
- 다양한 하드웨어와 운영 체제의 서로 다른 메모리 모델로부터 자바 프로그램을 보호하고자 따로 자바 메모리 모델을 정의했다. 
- 이 모델 덕분에 자바 프로그램은 플랫폼에 상관없이 메모리를 일관된 방식으로 이용할 수 있다. 

### 12.3.1 메인 메모리와 작업 메모리 
- 자바 메모리 모델의 주된 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정하는 것이다. 
- 여기서 말하는 변수는 인스턴스 필드, 정적 필드, 배열 객체의 원소만 포함한다. (스레드별로 고유 공간을 사용하는 지역변수, 매서드 매개 변수는 포함되지 않는다.)
- 자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다. 여기서 메인 메모리는 물리적인 것이 아니라 가상 머신이 관리하는 메모리이다. 
- 각 스레드는 자체 작업 메모리를 가지게 된다. (캐시와 비슷한 기능으로 해당 스레드가 사용하는 변수가 저장된다.)

### 12.3.2 메모리 간 상호 작용
- 메인 메모리에서 작업 메모리로 변수를 복사하고 다시 동기화하는 구체적인 방법을 자바 메모리 모델은 다음과 같이 8가지로 정의했다. 
- 자바 가상 머신은 각 단계의 연산이 원자적으로 이루어지도록 보장해야 한다. 
    - lock: 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다.
    - unlock: 잠겨있는 변수를 잠금 해제한다. 
    - read: 메인 메모리의 변수값을 특정 스레드의 작업 메모리로 전송한다. 
    - load: 읽기 연산으로 얻어온 값을 작업 메모리의 변수에 복사한다. 
    - use: 작업 메모리의 변수값을 실행 엔진으로 전달한다. 
    - assign: 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당한다. 
    - store: 뒤이어 수행되는 쓰기 연산을 위해 작업 메모리의 변수값을 메인 메모리로 전송한다.
    - write: 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리 변수에 기록한다. 
- 다음의 8가지 연산을 수행할 때 지켜야 하는 규칙이다. 
  - read/load, store/write 는 단독으로 수행될 수 없다. 
  - 스레드는 작업 메모리에서 변수값이 변경되면 메인 메모리로 동기화 해야 한다. 
  - 스레드는 작업 메모리 데이터를 아무 이유없이 메인 메모리로 동기화할 수 없다. 
  - 변수는 메인 메모리에서만 생성될 수 있다. 작업 메모리에 있는 초기화 되지 않는 변수는 사용하거나 저장하기 전에 store/write 가 이루어져야 한다.
  - 변수는 한 번에 한 스레드만 잠글 수 있다. 잠금이 여러 번 되었다면 해제 역시 동일한 횟수를 수행해야 한다. 
  - 변수를 잠그면 작업 메모리의 변숫값은 지워진다. 
  - 잠겨 있지 않는 변수나 다른 스레드가 잠근 변수에 대해서 잠금 해제 연산을 할 수 없다. 
  - 잠금을 해제하려면 변수를 메인 메모리로 동기화 해야 한다. 

### 12.3.3 volatile 변수용 특별 규칙 
- volatile 키워드는 자바 가상 머신이 제공하는 가장 가변운 동기화 매커니즘이다. 

#### 12.3.3.1 모든 스레드에서 이 변수에 가시성을 보장한다 
- 한 스레드가 값을 변경하면 다른 스레드들도 새로운 값을 즉시 알게 된다.
- volatile 변수를 사용한 작업은 동시성 환경에서 안전하다는 결론 과장이다. 
- volatile 변수가 스레드 안전하다면 아래 결과는 10_000 * 20 = 200_000 이 되어야 하지만 그렇게 나오지 않는다
- volatile 변수는 가시성만 보장하기에 다음 두 규칙을 충족하지 못한다. 
  - 연산 결과가 변수의 현재 값과는 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장한다. 
  - 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않는다.
```java
public class VolatileTest {
    public static volatile int race = 0;
    public static void increase() {
        race++; // 단일 연산처럼 보이지만 단일 연산이 아니다.
    }
    private static final int THREADS_COUNT = 20;
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[THREADS_COUNT];
        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10_000; j++) {
                    increase();
                }
            });
            threads[i].start();
        }
        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i].join();
        }
        System.out.println(race);
    }
}
```
- volatile 를 사용하여 동시성을 제어하는 매우 적합한 시나리오는 다음과 같다. 
- 이 코드는 shutdown() 메서드가 호출되면 모든 스레드에서 실행중인 doWork() 메서드가 즉시 종료됨을 보장한다. 
```java
volatile boolean shutdownRequested;
public void shutdown() {
    shutdownRequested = true;
}
public void doWork() {
  while (!shutdownRequested) {
      // do something
  }
}
```

#### 12.3.3.2 명령어 재정렬 최적화를 막아준다. 
- 일반 변수는 메서드 싱핼 중 할당 결과를 이용해야 하는 모든 위치에서 올바른 결과를 얻는다는 점만 보장될 뿐, 변수 할당 작업의 실행 순서가 프로그램 코드 순서와 동일하다는 보장은 없다.

### 12.3.4 long 과 double 변수용 특별 규칙
- 자바 메모리 모델에서는 잠금, 잠금 해제, 읽기, 적재, 할당, 사용, 저장, 쓰기 연산이 모두 원자적이어야 한다. 
- 하지만 64비트 데이터 타입인 long 과 double 에는 좀 더 느슨한 특별 규칙이 적용된다. 
- 가상 머신은 volatile 로 지정되지 않는 64bit 데이터에 대해 32bit 연산 2개로 나눠 처리할 수 있다. 
- 하지만 이런 현산은 거의 일어나지 않는다. 현재 주류 플랫폼이 64비트 가상 머신에서는 비원자적 접근이 일어나지 않는다. 
- 일부 32비트 x86 플랫폼은 long 타입 데이터를 비원자적으로 처리할 가능 위험이 있지만 double 의 경우 부동 소수점 데이터 전용 유닛을 탑재하고 있어 문제가 발생하지 않는다.

### 12.3.5 원자성, 가시성, 실행 순서
#### 12.3.5.1 원자성
- 애플리케이션 수준에서 원자성을 더 넒은 범위로 보장해야 할 떄를 위해 자바 메모리 모델은 잠금과 잠금 해제 연산을 제공한다. 
- 동기화된 블록 전체가 원자적으로 수행된다. 

#### 12.3.5.2 가시성 
- 공유 변수의 값을 한 스레드가 변경하면 다른 스레드가 즉시 알 수 있다는 뜻이다. 
- volatile 변수는 변수값이 수정되면 즉시 메인 메모리에 반영하고, 변수값을 읽을 때 메인 메모리로 부터 값을 갱신하는 방법으로 가시성을 확보한다. 
- 자바에는 가시성 확보용 키워드가 두개 더 있다. 바로 synchronized 와 final 이다. 
- synchronized 블록은 변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화하는 것으로 확보한다. 
- final 은 불변의 변수로 생성시에 이미 초기화 되고 변경할 수 없기에 확보할 수 있다. 

#### 12.3.5.3 실행 순서
- 명령어 재정렬과 작업 메모리와 메인 메모리 사이의 동기화 지연 현상으로 다른 스레드에서 보면 순서가 다를 수 있다. 
- 자바 언어는 스레드 사이에서도 작업 순서를 보장하기 위해 volatile 과 synchronized 키워드를 제공한다.
- volatile 은 그 자체에 명령어 재정렬을 금지한다라는 의미를 포함한다. 
- synchronized 는 락을 소유한 단 하나의 스레드만이 변수에 접근할 수 있다는 규칙에 의거 작업 순서를 정한다. 

### 12.3.6 선 발생 원칙
- 선 발생이란 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다. 
- 예를 들어 작업 A는 작업 B보다 선 발생한다 라고 하면 작업 B가 수행되기 전에 작업 A의 영향을 작업 B에서 관찰할 수 있다라는 뜻이다.
- 선 발생 원칙 
```text
i = 1; // 스레드 A
j = i; // 스레드 B
i = 2; // 스레드 C
```
- 스레드 A의 연산 i=1 이 스레드 B의 연산 j=i 보다 먼저 발생해야 한다고 가정하자. 그러면 B의 연산이 실행된후 변수 j의 값을 1이라고 결론 지을 수 있다. 
  - 선 발생 원칙에 따라 i=1의 결과를 관찰할 수 있다. 
  - 스레드 C는 아직 등장하지 않으면 스레드 A의 작업이 완료된 후 다른 스레드가 변수 i 값을 수정하지 않았다. 
- 다음 목록은 자연스러운 선 발생 관계이다. 동기화 장치의 지원 없이 이루어지면 코딩에 직접 활용할 수 있다. 
  - 프로그램 순서 규칙: 한 스레드 안에서 제어 흐름 순서에 따라 앞의 연산이 뒤따르는 연산보다 선 발생한다. 
  - 모니터 락 규칙: 잠금 해제 연산은 같은 락에 대한 잠금 연산보다 선 발생한다. 
  - 휘발성 변수 규칙: volatile 변수의 쓰기 연산은 같은 변수에 대한 읽기 연산보다 선 발생한다. 
  - 스레드 시작 규칙: Thread 객체의 start() 메서드는 해당 스레드의 어떤 작업보다 선 발생한다. 
  - 스레드 종료 규칙: 스레드의 모든 작업은 해당 스레드의 종료 감지보다 선발 생한다. 
  - 스레드 인터럽트 규칙: interrupt() 메서드 호출은 인터럽트되는 스레드가 인터럽트 이벤트 발생 감지보다 선 발생한다.
  - 종료자 규칙: 객체 초기화는 finalize() 메서드 시작보다 선 발생한다. 
  - 전이성: 연산 A가 연산 B보다 선 발생하고 연산 B가 연산 C보다 선 발생한다면, 연산 A 는 연산 C보다 선 발생한다. 
  

## 12.4 자바와 스레드 

### 12.4.1 스레드 구현
- 스레드는 프로세스보다 가벼운 스케줄링 단위다. 자원 할당과 실행 스케줄링 측며에서 스레드와 프로세스는 차이가 있다. 
- 스레드는 각각은 프로세스 자원등을 공유할 수 있으며, 독립적으로 스케줄링 된다. 

#### 12.4.1.1 커널 스레드 구현 
- 커널 스레드를 이용하는 구현을 1:1 구현이라고 한다. 커널 스레드는 운영 체제에서 직접 지원하는 스레드이며, 스레드 작업을 각 프로세서에 매핑하는 역할을 한다. 
- 프로그램은 일반적으로 커널 스레드를 직접 사용하지 않고, 대신 커널 스레드의 고수준 인터페이스인 경량 프로세스를 이용한다. (일반적으로 스레드라 부름)
- 경량 프로세스 각각은 커널 스레드의 도움을 받기 떄문에 커널 스레드가 먼저 지원되어야 경량 프로세스도 존재할 수 있다. 
- 경량 프로세스와 커널 스레드 사이의 1ㅣ1 관계를 일대일 스레드 모델이라고 한다. 
- 경량 프로세스는 두가지 한계를 지닌다. 
  - 커널 스레드 기반으로 구현되어 생성, 소멸, 동기화 등 다양한 스레드 연산이 시스템 호출로 이루어지고, 이는 실행 비용이 높다.
  - 경량 프로세스 하나가 커널 스레드 하나에 매핑되기 때문에 프로세스는 일정량의 커널 자원을 소모한다. 따라서 지원할 수있는 개수에는 제한이 있다. 

#### 12.4.1.2 사용자 스레드 구현
- 사용자 스레드를 이용하는 구현을 1:N 구현이라고 한다. 
- 커널 스레드가 아닌 이상 모든 스레드는 일종의 사용자 스레드로 볼수 있고 경량 프로세스 역시 사용자 스레드에 속한다. 
- 사용자 스레드는 온전히 사용자 공간에서 구현되는 스레드 라이브러리를 가리킨다. 따라서 운영 체제 커널은 사용자 스레드의 존재와 구현 방법을 알지 못한다. 
- 프로세스와 사용자 스레드 사이의 이러한 1:N 관계를 일대다 스레딩 모델이라 한다. 
- 사용자 스레드 장법은 시스템 커널의 지원이 필요 없다는 것인데, 단점 역시 지원을 받지 못한다는 것이다. 
- 스레드의 생성, 소멸, 동기화, 스케줄링 등 모근 작업을 사용자 프로그램 자체에서 처리해야 한다. 

#### 12.4.1.3 하이브리드 구현
- 커널, 사용자 스레드를 함께 이용하는 하이브리드 구현 방법이 있다. 이름 M:N 구현이라 한다.
- 하이브리드 모든에서는 사용자 스레드와 경량 프로세스의 비율이 불확실한 N:M 관계이며, 이를 다대다 스레딩 모델이라 한다.


#### 12.4.1.4 자바 스레드 구현
- 자바 스레드 구현 방식은 규정하지 않고 있으므로 가상 머신에 따라 다를수 있다. 
- 핫스팟은 기본 스레드 모델을 기반은 일대일 스레딩 모델을 사용한다. 

### 12.4.2 자바 스레드 스케줄링
- 스레드 스케줄링이란 시스템이 프로세서 사용 권한을 스레드에 할당하는 일이다. 
- 주요 스케줄링 방법으로는 협력적 스케줄링과 선점형 스케줄링이 있다. 
- 협력적 스케줄링 시스템에서는 스레드 실행 시간을 스레드 스스로 제어한다. 따라서 일을 마친 스레드는 다른 스레드로 전환되도록 시스템에 적극적으로 알려야 한다. 
- 협력적 스케줄링 구현하기 쉽고, 동기화 문제가 발생하지 않는다 
- 단점은 스레드 실행 시간을 제어할 수 없고 스레드 코드에 문제가 있어서 시스템에 요청을 하지 않으면 프로그램이 멈춰 버린다.
- 선점형 스케줄링 방식에서는 각 스레드의 실행 시간을 시스템이 할당한다. 스레드들은 전환 시점을 스스로 결정하지 못한다. 

### 12.4.3 상태 전이 
- 자바 언어에서 스레드의 상태는 총 여섯 가지다. 스레드는 이 중 한상태에 놓이며, 특정 메서드를 호출하여 다른 사태로 전이할 수 있다. 
  - 신규: 스레드 생성 후 아직 시작되기 전 상태
  - 실행 중: 실행 중과 준비에 해당한다. 스레드가 실행중이거나 운영 체제가 실행 시간을 할당하기를 기다리는 중이다. 
  - 무기한 대기: 다른 스레드가 명시적으로 깨워 주기를 기다리는 중이다.
  - 시간 제한 대기: 무기한 대기처럼 기다리지만 일정시간이 이나면 자동으로 깨어난다.
  - 블록: 배타적 락을 얻기를 기다린다는 점에서 대기와 차이가 있다. 
  - 종료: 스레드가 실행을 마쳤다.