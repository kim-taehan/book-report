# 7장 클래스 로딩 메커니즘
## 7.1 들어가며
- 가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신안에서 활용하는 방법을 알아본다. 

## 7.2 클래스 로딩 시점
- 타입의 생애 주기는 로딩->검증->준비->해석->초기화->사용->언로딩 단계로 이루어지며, 검증부터 해석단계를 링킹이라고 한다.
- 로딩, 검증, 준비, 초기화, 언로딩은 순서대로 진행해야 되지만 해석 단계는 때에 따라서 초기화 후 시작될 수 있다. (동적 바인딩 지원)
- 초기화가 즉시 시작되어야 하는 6가지 상황
  - 바이트코드 명령어인 new(객체의 인스턴스 생성), getstatic(타입의 정적 필드를 읽기), putstatic(타입의 정적 필드를 설정), invokestatic(정적 메서드 호출)
  - 리플렉션 메서드를 사용시에 해당 타입이 초기화되지 않은 경우
  - 클래스를 초기화할 때 상위 클래스가 초기화 되지 않은 경우
  - 가상 머신은 구동 직후 사용자가 지정한 메인 타입을 찾아 실행한다 (이때 메인 타입의 초기화 시도)
  - 메서드 핸들을 해석 얻은 인스턴스를 호출시
  - 인터페이스에 default 메서드를 정의했다면, 구현 클래스가 초기화될 때 인터페이스 부터 초기화 한다. 
- 타입 초기화를 촉발하지 않는 모든 참조 방식은 수동참조라고 한다. 
  - 정적 필드를 참조할 때는 필드를 직접 정의한 클래스만 초기화 된다. 
  - 배열 객체를 생성시 `new SimpleClass[10];`
  - 타입에 정의된 정적 필드를 static final 을 사용시에 컴파일 과정에서 상수 전파 최적화로 인해 상수 풀을 사용하게 되어 차이가 존재
  
```java
public class SuperClass {

    static {
        System.out.println("클래스 초기화!!");
    }

    public static String value1 = "1234";
    public static final String value2 = "1234";

}
```

## 7.3 클래스 로딩 처리 과정
### 7.3.1 로딩 
- 자바 가상 머신은 로딩 단계에서 다음 세 가지 작업을 수행한다. 
  - 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
  - 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
  - 로딩 대상 클래스를 표현하는 `java.lang.Class` 객체를 힙 메모리에 생성한다. 
- `자바 가상 머신 명세`가 로딩 요구사항을 세세하게 정의하지 않은 덕분에 개발자들이 참신한 기법을 사용해 수많은 자바 기술이 생성되었다. 
  - ZIP 압축 파일로부터 로딩 (jar, war 파일 형식의 기초)
  - 네트워크로부터 로딩 (웹 애플릿)
  - 런타임에 동적으로 생성(프락시 기술)
  - 다른 파일로 생성(jsp)
  - 데이터베이스로 로딩
  - 암호화도니 파일로부터 로딩(디컴파일 제약)

### 7.3.2 검증 
- 검증은 링킹 과정 중 첫 번째 단계이며, 목적은 다음 2가지 이다. 
  - 클래스 파일의 바이트 스트림에 담긴 정보가 `자바 가상 머신 명세`에서 규정한 제약을 만족하는가?
  - 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.
- 클래스 파일을 꼭 자바 소스코드로 컴파일해야 하는 것은 아니고, 바이너리 편집기로 위변조가 가능하다. 
- 1 파일 형식 검증
  - 바이트 스트림이 클래스 파일 형식에 부합하고 현재 버전의 가상 머신에서 처리될 수 있는지 확인한다. 
- 2 메타 데이터 검증
  - 바이트 코드로 설명된 정보의 의미를 분석하여 정보가 요구 사항을 충족하는지 확인한다.
- 3 바이트 코드 검증
  - 데이터 흐름과 제어 흐름을 분석하여 프로그램의 의미가 적법하고 논리적인지 확인하는 것이다. 
- 4 심벌 참조 검증
  - 가상 머신이 심벌 참조를 직접 참조로 변환할때 수행된다. 이 변환은 해석 단계에서 일어난다. 
  - 해당 클래스 자체를 제외한 모든 정보를 확인하는 것으로 보면 된다. 

### 7.3.3 준비
- 클래스 변수를 메모리에 할당하고 초긱값을 설정하는 단계이다. 
- 인스턴스 변수는 객체가 인스턴스화 될때 객체와 함께 자바 힙에 할당된다. 
- 준비 단계에서 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로 값이다. (클래스 초기화 단계에 직접 값이 입력된다.)
- 단 static final 로 정의하면 value에 값이 준비단계에서 할당된다. 


### 7.3.4 해석
- jvm 이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다. 
- 심벌 참조: 몇 가지 심벌로 참조 대상을 설명한다. 
- 직접 참조: 포인터, 상대적 위치 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 

### 7.3.5 초기화
- 초기화 단계란 클래스 생성자인 <clinit>() 메서드를 실행하는 단계이다. 
- <clinit>()는 모든 클래스 변수 할당과 정적 문장 블록의 내용의 취합하여 컴파일러가 자동으로 생성한다. 
```java
public class InitClass {

    static {
        System.out.println("정적 문장 블록");
    }
    public InitClass() {
        System.out.println("생성자 호출");
    }
}
```

## 7.4 클래스 로더
- 클래스 로딩 단계 중 `완전한 이름을 보고 해당 클래스를 정의하는 바이트 스트림 가져오기` 역할을 하는 것이 클래스 로더이다. 

### 7.4.1 클래스와 클래스 로더 
- 클래스 로더는 독립적인 클래스 이름 공간을 지니기 때문에 클래스 로더를 뺴놓고 특정 클래스가 자바 가상 머신에서 유일한지 판단할 수 없다. 

### 7.4.2 부모 위임 모델
- 자바 가상 머신 관점에서는 클래스 로더의 종류
  - 자바 가상 머신 자체의 일부인 부트스트랩 클래스 로더: 핫스팟 가상 머신에서는 C++로 구현됐다.
  - 그 외 모든 클래스 로더: 추상클래스인 `java.lang.ClassLoader` 를 상속하여 외부에 독립적으로 존재한다. 
- 자바 개발자 입장에서는 더 잘게 나눌 수 있다. 
  - 부트스트랩 클래스 로더: `JAVA_HOME/lib` 디렉터리나 -Xbootclasspath 매개 변수로 지정한 경로에 위치한 파일들과 
  자바 가상머신이 클래스 라이브러리 인식하는 파일들을 로드한다. 
  - 확장 클래스 로더: `sun.misc.Launcher$ExtClassLoader`를 말하며 자바로 구현되었다. `JAVA_HOME/lib/ext` 디렉토리 또는
  `java.ext.dirs` 시스템 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할을 한다.
  - 애플리케이션 클래스 로더: `sun.misc.Launcher$AppClassLoader`를 말한다. 클래스패스상 클래스 라이브러리들을 로드하는 역할
  애플리케이션에서 클래스 로더를 따로 만들어 이용하지 않는 경우 이 로더가 기본 클래스 로더가 된다.