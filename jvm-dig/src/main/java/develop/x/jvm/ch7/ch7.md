# 7장 클래스 로딩 메커니즘
## 7.1 들어가며
- 가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신안에서 활용하는 방법을 알아본다. 

## 7.2 클래스 로딩 시점
- 타입의 생애 주기는 로딩->검증->준비->해석->초기화->사용->언로딩 단계로 이루어지며, 검증부터 해석단계를 링킹이라고 한다.
- 로딩, 검증, 준비, 초기화, 언로딩은 순서대로 진행해야 되지만 해석 단계는 때에 따라서 초기화 후 시작될 수 있다. (동적 바인딩 지원)
- 초기화가 즉시 시작되어야 하는 6가지 상황
  - 바이트코드 명령어인 new(객체의 인스턴스 생성), getstatic(타입의 정적 필드를 읽기), putstatic(타입의 정적 필드를 설정), invokestatic(정적 메서드 호출)
  - 리플렉션 메서드를 사용시에 해당 타입이 초기화되지 않은 경우
  - 클래스를 초기화할 때 상위 클래스가 초기화 되지 않은 경우
  - 가상 머신은 구동 직후 사용자가 지정한 메인 타입을 찾아 실행한다 (이때 메인 타입의 초기화 시도)
  - 메서드 핸들을 해석 얻은 인스턴스를 호출시
  - 인터페이스에 default 메서드를 정의했다면, 구현 클래스가 초기화될 때 인터페이스 부터 초기화 한다. 
- 타입 초기화를 촉발하지 않는 모든 참조 방식은 수동참조라고 한다. 
  - 정적 필드를 참조할 때는 필드를 직접 정의한 클래스만 초기화 된다. 
  - 배열 객체를 생성시 `new SimpleClass[10];`
  - 타입에 정의된 정적 필드를 static final 을 사용시에 컴파일 과정에서 상수 전파 최적화로 인해 상수 풀을 사용하게 되어 차이가 존재
  
```java
public class SuperClass {

    static {
        System.out.println("클래스 초기화!!");
    }

    public static String value1 = "1234";
    public static final String value2 = "1234";

}
```

## 7.3 클래스 로딩 처리 과정
### 7.3.1 로딩 
- 자바 가상 머신은 로딩 단계에서 다음 세 가지 작업을 수행한다. 
  - 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
  - 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
  - 로딩 대상 클래스를 표현하는 `java.lang.Class` 객체를 힙 메모리에 생성한다. 
- `자바 가상 머신 명세`가 로딩 요구사항을 세세하게 정의하지 않은 덕분에 개발자들이 참신한 기법을 사용해 수많은 자바 기술이 생성되었다. 
  - ZIP 압축 파일로부터 로딩 (jar, war 파일 형식의 기초)
  - 네트워크로부터 로딩 (웹 애플릿)
  - 런타임에 동적으로 생성(프락시 기술)
  - 다른 파일로 생성(jsp)
  - 데이터베이스로 로딩
  - 암호화도니 파일로부터 로딩(디컴파일 제약)

### 7.3.2 검증 
- 검증은 링킹 과정 중 첫 번째 단계이며, 목적은 다음 2가지 이다. 
  - 클래스 파일의 바이트 스트림에 담긴 정보가 `자바 가상 머신 명세`에서 규정한 제약을 만족하는가?
  - 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.
- 클래스 파일을 꼭 자바 소스코드로 컴파일해야 하는 것은 아니고, 바이너리 편집기로 위변조가 가능하다. 
- 1 파일 형식 검증
  - 바이트 스트림이 클래스 파일 형식에 부합하고 현재 버전의 가상 머신에서 처리될 수 있는지 확인한다. 
- 2 메타 데이터 검증
  - 바이트 코드로 설명된 정보의 의미를 분석하여 정보가 요구 사항을 충족하는지 확인한다.
- 3 바이트 코드 검증
  - 데이터 흐름과 제어 흐름을 분석하여 프로그램의 의미가 적법하고 논리적인지 확인하는 것이다. 
- 4 심벌 참조 검증
  - 가상 머신이 심벌 참조를 직접 참조로 변환할때 수행된다. 이 변환은 해석 단계에서 일어난다. 
  - 해당 클래스 자체를 제외한 모든 정보를 확인하는 것으로 보면 된다. 

### 7.3.3 준비
- 클래스 변수를 메모리에 할당하고 초긱값을 설정하는 단계이다. 
- 인스턴스 변수는 객체가 인스턴스화 될때 객체와 함께 자바 힙에 할당된다. 
- 준비 단계에서 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로 값이다. (클래스 초기화 단계에 직접 값이 입력된다.)
- 단 static final 로 정의하면 value에 값이 준비단계에서 할당된다. 


### 7.3.4 해석
- jvm 이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다. 
- 심벌 참조: 몇 가지 심벌로 참조 대상을 설명한다. 
- 직접 참조: 포인터, 상대적 위치 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 

### 7.3.5 초기화
- 초기화 단계란 클래스 생성자인 <clinit>() 메서드를 실행하는 단계이다. 
- <clinit>()는 모든 클래스 변수 할당과 정적 문장 블록의 내용의 취합하여 컴파일러가 자동으로 생성한다. 
```java
public class InitClass {

    static {
        System.out.println("정적 문장 블록");
    }
    public InitClass() {
        System.out.println("생성자 호출");
    }
}
```

## 7.4 클래스 로더
- 클래스 로딩 단계 중 `완전한 이름을 보고 해당 클래스를 정의하는 바이트 스트림 가져오기` 역할을 하는 것이 클래스 로더이다. 

### 7.4.1 클래스와 클래스 로더 
- 클래스 로더는 독립적인 클래스 이름 공간을 지니기 때문에 클래스 로더를 뺴놓고 특정 클래스가 자바 가상 머신에서 유일한지 판단할 수 없다. 

### 7.4.2 부모 위임 모델
- 자바 가상 머신 관점에서는 클래스 로더의 종류
  - 자바 가상 머신 자체의 일부인 부트스트랩 클래스 로더: 핫스팟 가상 머신에서는 C++로 구현됐다.
  - 그 외 모든 클래스 로더: 추상클래스인 `java.lang.ClassLoader` 를 상속하여 외부에 독립적으로 존재한다. 
- 자바 개발자 입장에서는 더 잘게 나눌 수 있다. 
  - 부트스트랩 클래스 로더: `JAVA_HOME/lib` 디렉터리나 -Xbootclasspath 매개 변수로 지정한 경로에 위치한 파일들과 
  자바 가상머신이 클래스 라이브러리 인식하는 파일들을 로드한다. 
  - 확장 클래스 로더: `sun.misc.Launcher$ExtClassLoader`를 말하며 자바로 구현되었다. `JAVA_HOME/lib/ext` 디렉토리 또는
  `java.ext.dirs` 시스템 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할을 한다.
  - 애플리케이션 클래스 로더: `sun.misc.Launcher$AppClassLoader`를 말한다. 클래스패스상 클래스 라이브러리들을 로드하는 역할
  애플리케이션에서 클래스 로더를 따로 만들어 이용하지 않는 경우 이 로더가 기본 클래스 로더가 된다.
- 부모 위임 모델 동작
  - 클래스 로딩을 요청받은 클래스 로더는 처음부터 클래스 자체를 로드하려 시도하지 않는다.
  - 대신 수준에 맞는 상위 클래스 로더로 요청을 위임한다.
  - 따라서 모든 로드 요청은 우선 최상위인 부트스트랩 클래스 로더로 넘겨진다.
  - 상위 로더가 자신이 처리할 요청이 아니라고 판단하면, 비로서 하위로더가 시도한다.

### 7.4.3 부모 위임 모델에 대한 도전

#### 7.4.3.1 첫 번째 도전
- JDK 1.2의 ClassLoader 는 loadClass()를 하위 클래스에서 오버라이딩 못하게 하고, 그 대신 protected 메서드인 findClass()를 추가했다.
- 자체 클래스 로더를 작성하는 개발자에게 findClass()를 오버라이딩한 후 loadClass() 안에서 호출하라고 안내했다.

#### 7.4.3.2 두 번째 도전
- 스레드별 콘텍스트 클래스 로더를 도입했다. 이 로더는 `java.lang.Thread` 의 setContextClassLoader() 메서드로 설정할 수 있다.
- 스레드 생성 시 따로 설정하지 않으면 부모 스레드의 로더 물려받고, 애플리케이션 전역 범위로 설정하지 않는다면 애플리케이션 클래스 로더가 사용된다.

#### 7.4.3.3 세 번째 도전
- 사용자들이 프로그램에 동적인 능력을 부여하길 원해 직면한 도전이다. 
- 구성 요소들을 런타임에 교체하거나 추가할 수 있게 되는 것이다. 

## 7.5 자바 모듈 시스템
- 직소 프로젝트 결과로 JDK 9에 도입된 모듈 시스템(JPMS)은 자바 기술에 있어 중요한 개선이다. 
- 모듈화란 `자유롭게 설정 가능한 캡슐화 격리 매커니즘`을 만들기 위해 자바 가상 머신은 클래스 로딩 아키텍처를 변형했다.

| 레벨| 설명|
| --| --|
| required| 다른 모듈에 대한 의존성 목록|
| exports| 다른 모듈에서 사용할 수 있는 패키지 목록|
| open| 다른 모듈에서 리플렉션 API로 접근할 수 있는 패키지|
| uses| 현재 모듈이 사용할 서비스 목록|
| provides| 다른 모듈에 제공하는 서비스 목록|
- 이전까지는 필요한 타입이 클래스패스에 없더라도 프로그램이 그 타입을 처음 사용하려 할때에 예외가 보고 되었다. 
- 반면 모듈이 의존하는 다른 모듈들을 명시할 수 있어 애플리케이션 개발 단계에서 확인할 수 있게 되었다. 
- 또한 public 중에서도 외부 모듈에 공개할 타입을 따로 명시할 수 있다. 

### 7.5.1 모듈 호환성
- 자바 모듈 시스템이 기존 클래스패스 방식과 호환되도록 하기 위해 JDK 9에서는 클래스패스에 해당하는 모듈패스 개념을 도입했다.
- 클래스패스상의 jar 파일용 접근 규칙:
  - 클래스패스에 있는 모든 JAR 파일과 기타 리소스 파일은 자동으로 익명 모듈로 패키징된 것으로 간주한다.
- 모듈패스상의 모듈용 접근 규칙:
  - 모듈패스에 존재하는 명명된 모듈은 자신의 의존성 정의에서 명시한 모듈과 패키지에만 접근할 수 있다. 
- 모듈패스상의 jar 파일용 접근 규칙:
  - 모듈 정의가 포함되지 않은 기존 jar 파일을 모듈패스에 넣어 두면 자동으로 모듈이 된다. 
  - module-info.class 파일이 없는 모듈은 기본적으로 자신의 패키지를 모두 익스포트하며, 모듈패스에 존재하는 다른 모든 모듈에 의존한다. 


### 7.5.2 모듈화 시대의 클래스 로더 
- jdk 9에서 반영된 모듈 시스템으로 인해 클래스 로더도 변경점이 생겼다
- 1 확장 클래스 로더가 플랫폼 클래스 로더로 대체되었다. 
  - jdk 전체가 모듈화 되면서 모듈들 안의 클래스 라이브러리들은 자연스럽게 확장성 요구 사항을 충족하게 되었다. 
- 2 플랫폼 클래스 로더와 애플리케이션 클래스 로더가 더는 `java.net.URLClassLoader`로부터 파생되지 않는다.
  - `java.internal.loader.BuiltinClassLoader`에서 파생된다. 
- 3 플랫폼 및 애플리케이션 클래스 로더는 부모 로더에 위임하기 전에 특정 시스템 모듈에 속하는지 먼저 확인한다. 