# 3장 가비지 컬렉터와 메모리 할당 전략


## 3.1 들어가며
- 가비지 컬렉션이 처리해야 하는 문제 3가지 
  - 어떤 메모리를
  - 언제
  - 어떻게
- 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면
- 이 자동화된 기술을 적절히 모니터링하고 조율할 수 있어야 한다. 
- 프로그램 카운터, 가상 머신 스택, 네이티브 메서드 스택은 스레드와 함께 생성되고 소멸된다. 따라서 여기는 어떻게 회수할지는 고민하지 않아도 된다. 
- 자바 힙과 메서드 영역은 불확실한 게 아주 많다. 같은 인터페이스라도 조건에 따라 메모리 요구량이 달라질 수 있다. (오직 런타임 시점에 알 수 있다.)
- 가비지 컬렉터는 바로 이영역(자바 힙, 메서드 영역) 을 관리하는데 집중하게 된다. 

## 3.2 대상이 죽었는가? 
- 자바 세계에서는 거의 모든 객체 인스턴스가 힙에 저장된다. 
- 가비지 컬렉터가 힙을 청소하려면 어떤 객체가 살아 있고, 죽었는지를 판단해야 한다. 

### 3.2.1 참조 카운팅 알고리즘
> 1 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 늘어날 때마다 카운터 값을 1씩 증가시킨다.   
> 2 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.   
> 3 카운터 값이 0이 된 객체는 더는 사용할 수 없다. 
- 간단한 참조 카운팅만으로는 순환 참조 문제를 풀기 어렵다. 
- -Xlog:gc* 매개 변수를 지정하여 가비지 컬렉션 정보를 자세히 출력한다. 
```java

/**
 * vm args : -Xlog:gc*
 */
public class ReferenceCountingGC {

    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB];


    public static void main(String[] args) {
        testGc();
    }

    private static void testGc() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
```

### 3.2.2 도달 가능성 분석 알고리즘 
- 자바, C# 등은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다. 
- 이 알고리즘의 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 
- 어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해진다. 
- 자바에서 GC 루트로 이용할 수 있는 객체는 다음과 같이 정해져 있다. 
  - 가상 머신 스택에서 참조하는 객체: 현재 실행중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수등
  - 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: 자바 클래스의 참조 타입 정적 변수
  - 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
  - 네이티브 메서드 스택에서 JNI(이른바 네이티브 메서드)가 참조하는 객체
  - 자바 가상 머신 내부에서 쓰이는 참조: 기본 데이터 타입에 해당하는 class 객체, 일부 상주 예외 객체, 시스템 클래스 로더
  - 동기화 락(synchronized 키워드)으로 잠겨 있는 모든 객체
  - 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등

### 3.2.3 다시 참조 이야기로
- 객체의 생사 판단과 '참조'는 떼어서 생각할 수 없다. 
- JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지 구분하기 시작했다. 
  - 강한 참조: 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조 관계가 남아 있는 객체는 가비지 컬렉터가 절대 회수하지 않는다.
  - 부드러운 참조: 유용하지만 필수는 아닌 객체를 표현한다. 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 
  - 약한 참조: 부드러운 참조보다 연결 강도가 더 약하며 다음번 가비지 컬렉션까지만 살아 있다. 메모리가 넉넉하더라도 가비지 컬렉터가 회수한다. 
  - 유령 참조: 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하며, 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.

### 3.2.4 살았나 죽었나?
- 도달 가능성 분석 알고리즘이 '도달 불가능'으로 판단한 객체라고 해서 반드시 죽여야 하는 건 아니다. 확실한 사망 선고를 내리려면 두 번의 표시과정을 거쳐야 한다. 
- 도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다. 
- 필터링 조건은 종료자 finalize() 메서드를 호출해야 되는 객체인가 이다.
- finalize() 를 실행해야 하는 개체는 F-Queue 라는 대기열에 추가 되고, 가상 머신이 우선순위 낮은 종료자 스레드를 생성해 finalize() 메서드를 실행한다. 
- finalize() 가능한 사용하지 말자 그리고 이미 deprecated 된 상태이다.

### 3.2.5 메서드 영역 회수하기 
- 메서드 영역 가비지 컬렉션은 대체로 비용 효율이 좋지 않다. 자바 힙은 가비 컬렉션 한 번으로 메모리 70-99% 를 회수한다. 
- 메서드 영역 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용되지 않는 상수와 클래스다.
- 상수를 회수하는 법
  - 문자열 `java`가 상수 풀에 들어 있으나 현재 시스템에서 값이 `java`인 문자열 객체는 하나도 없다고 가정
  - 가상 머신에서 이 러터럴을 사용하는 코드가 한 곳도 없다. 
  - 이 시점에 회수가 시작되면 GC는 `java` 상수를 상수 풀에서 치워 버려야 한다고 판단한다.
- 더 이상 쓰이지 않는 클래스인지 판단하는 조건 
  - 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다. 
  - 이 클래스를 읽어 들인 클래스 로더가 회수되었다. (OSGi나 JSP 리로딩 처럼 세심하게 설계된 대안클래스 로도없이 불가능)
  - 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다. 

## 3.3 가비지 컬렉션 알고리즘 
- 객체의 생사를 판별하는 방식을 기준으로 가비지 컬렉션 알고리즘을 `참조 카운팅 GC` 와 `추적 GC`로 나눌 수 있다. 
- 이 둘은 `직접 가비지 컬렉션`과 `간접 가비지 컬렉션`이라 부르기도 한다.

### 3.3.1 세대 단위 컬렉션 이론 
- 상용 가상 머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초한다. 
  - 1. 약한 세대 가설: 대다수 객체는 일찍 죽는다. 
  - 2. 강한 세대 가설: GC 과정에서 살아남은 횟수가 늘어날수록 오래 살 가능성이 커진다. 
- 이 두가지 가정이 합쳐서 널리 알려진 가지비 컬렉터들에 일관된 설계 원칙을 제공한다. 
- 영역 안에 객체 대부분이 곧바로 죽을 운명이라면, 그 객체들을 한데 몰아놓고 살아남는 소수의 객체를 유지하는 방법이 유리하다.
- 자바 힙을 여러 영역으로 나누면 GC 는 일부 영역만 선택하여 회수할 있다 (마이너 GC, 메이저 GC, 전체 GC)












