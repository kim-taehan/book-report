# 1장 모놀리식 지옥에서 벗어나라
## 1.1 서서히 모놀리식 지옥에 빠져들다. (FTCO 애플리케이션)
> FTCO 애플리케이션의 비지니스는 소비자가 FTCO 웹 사이트 또는 모바일 앱에 접속하여 인근 음식점에 주문하면 배달원이 음식을 픽업해서 소비자에게 배달하는 것
- 여타 다른 애플리케이션처러 FTCO 애플리케이션 역시 하나의 WAR 파일로 구성된 모놀리스로 개발되었다. 

### 1.1.1 FTCO 애플리케이션 아키텍처
- 전형적인 엔터프라이즈 자바 애플리케이션인 FTCO의 전체 구조는 코어가 비즈니스 로직으로 구성되어 하나의 war 파일로 배포하는 형태이다. 
- UI 구현 및 외부 시스템 통합을 담당하는 다양한 어댑터가 이 비지니스 코어를 깜싼 모양새로 구성되어 있다. 
- 논리적으로 모듈화한 아키텍처임에도 애플이케이션은 war 파일 하나로 패키징하게 됩니다. 

### 1.1.2 모놀리식 아키텍처의 장점
- 규모가 작았던 FTCO 시스템은 모놀리식 아키텍처가 장점이 많았습니다.
  - 개발이 간단하다.
  - 애플리케이션을 쉽게 변경할 수 있다. 
  - 테스트하기 쉽다.
  - 배포하기 쉽다.
  - 확장하기 쉽다.
- 하지만 시간이 흐를수록 개발, 테스트, 배포, 확장하기가 더 어려워졌습니다.

### 1.1.3 모놀리식 지옥의 실상
- FTCO처럼 성공한 애플리케이션은 모놀리식 아키텍처라는 옷이 더 이상 맞지 않게 커집니다. 
- 개발 팀이 스프린트를 할 떄하마 추가 구현할 스토리(테스트 케이스)가 늘어났고, 그만큼 코드베이스와 관리 오버헤드 역시 증가했습니다. 
- 당초 소규모였던 개발 팀도 이제는 팀별로 기능 분야가 특화된 스크럼 팀만 여럿입니다. 
  - 너무 복잡해서 개발자가 주눅 들다
  - 개발이 더디다
  - 커밋부터 배포에 이르는 길고 험난한 여정 
  - 확장하기 어렵다. (서버의 리소스 요건이 상이한 모듈이 존재하므로 최적화하기가 싶지않다)
  - 모놀리스는 확실하게 전달하기 어렵다. 
  - 한물간 기술 스택에 발목이 붙잡히다.

## 1.2 이책의 대상 독자
- si 개발자인 나지 뭐..

## 1.3 이 책의 학습 내용

### 1.3.1 배우는 내용
- 마이크로서비스의 주요 특성과 장단점, 사용 시점
- 분산 데이터 관리 패턴
- 효과적인 마이크로서비스 테스트 전략
- 마이크로서비스 배포 옵션
- 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링 하는 전략

### 1.3.2 할 수 있는 일
- 마이크로서비스 아키텍처 패턴으로 애플리케니션을 아키텍처링합니다. 
- 서비스 비지니스 로직을 개발합니다.
- 사가를 이용하여 서비스간 데이터 일관성 유지
- 여러 서비스에 걸친 쿼리를 구현
- 마이크로서비스를 효율적으로 테스트한다.
- 안전하고, 구성 가능하고, 관측 가능한 프로덕션 레디 서비스를 개발

## 1.4 마이크로서비스 아키텍처가 답이다.
- FIGO 애플리케이션은 몸집이 커시면서 여러가지 품질 속성이 악화되었다. (유지보수성, 확장성, 테스트성)
- 훈련이 잘된 개발자들만 작업을 하는 것이 아니기에 모놀리식 지옥에 빠질 수 밖에 없다.

### 1.4.1 확장 큐브와 마이크로서비스
- 확장 큐브는 3차원 큐브로 애플리케이션을 x,y,z 축 세방향을 확장시킬 수 있다. 
  - x축: 동일한 다중 인스터스에 들어온 요청을 부하 분산한다.
  - x축: 요청의 속성에 따라 요청을 라우팅한다.
  - y축: 기능에 따라 서비스를 분해한다.

#### 1.4.1 x축 확장: 다중 인스턴스에 고루 요청 분산
- 일반적인 모놀리식 애플리케이션 확장 수단입니다. 
- 부하 분산기 뒷면에 인스턴스를 N개 띄워 놓고 들어온 요청을 인스턴스에 고루 분해합니다.

#### 1.4.2 z축 확장: 요청 속성별 라우팅 
- 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법
- z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단

#### 1.4.3 y축 확장: 기능에 따라 애플리케이션을 서비스로 분해
- x,z 축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만 점점 더 복잡해지는 문제는 해결되지 않는다. 
- 따라서 y축 확장 기능분해가 필요합니다. 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것입니다. 
- 마이크로서비스는 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일입니다. 각 서비스가 집중된/응집된 책임을 맡고 있다는 것이 중요하다.

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다. 
- 모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성입니다. 여러 사람이 이해하고 개발할 수 있게 애플리케이션을 여러 모듈로 분해합니다.
- 마이크로서비스는 서비스를 모듈성의 단위로 사용하는데, 각 서비스는 다른 서비스가 함부로 침투하지 못하게 API라는 경계선을 가지고 있다. 
- 따라서 시간이 지나도 애플이케이션 모듈성을 유지할 수 있게 되어 독립적으로 배포/확장할 수 있는 장점이 있다. 

### 1.4.3 서비스마다 DB가 따로 있다. 
- 마이크로서비스는 느슨하게 결합되어 있고, 오직 API를 통해서만 통신하기에 각각 자체의 DB를 가지게 된다. 

### 1.4.4 FTGO 마이크로서비스 아키텍처
- FTGO 애플리케이션의 비지니스 로직은 REST API와 자체 프라이빗 데이터 저장소를 소유한 다양한 백엔드 서비스로 구성됩니다. 
  - 주문 서비스
  - 배달 서비스
  - 음식점 서비스
  - 주방 서비스
  - 회계 서비스

### 1.4.5 마이크로서비스 아키텍처와 SOA(Service Oriented Architecture)
| 구분| SOA| 마이크로서비스|
|--|--|--|
|구분| SOA| 마이크로서비스|
|서비스간 통신| SOAP, WS 표준처럼 무거운 프로토콜| REST나 gRPC처러 가벼운 프로토콜|
|데이터| 통합 DB| 개별 DB|
|주요 사례| 대규모 모놀리식 애플리케이션| 소규모 서비스|


## 1.5 마이크로서비스 아키텍처의 장단점

### 1.5.1 마이크로서비스 아키텍처 장점
- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다. 
  - 테스트성: 지속적 전달/배포를 하려면 자동화 테스트가 꼭 필요하다. 마이크로서비스는 상대적으로 크기가 작아서 테스트를 작성하기 쉽다.
  - 배포성: 독립적으로 배포가 가능해 다른 개발자와 협의할 필요가 적다.
  - 자율성, 느슨한 결합: 작은 팀이 여럿 결합된 기술 조직을 꾸려 갈 수 있다. 
- 서비스 규모가 작아 관리하기 쉽다.
  - 마이크로서비스는 비교적 크기가 작아서 개발자가 이해하기 쉽다. 
  - 각 서비스를 시동하는 시간이 빠르기 때문에 배포하는 과정도 생산적이다.
- 서비스를 독립적으로 배포/확장 할 수 있다. 
  - 마이크로서비스는 독립적으로 X,Y 축 확장을 할 수 있고, 서비스마다 상이한 리소스 요건에 맞추어 하드웨어에 배포할 수 있다. 
- 마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움직인다.
- 결함 격리가 잘된다.
  - 어느 서비스에 메모리 누수가 발생하더라도 해당 서비스만 영향을 받는다.
- 새로운 기술을 실험하고 도입하기 쉽다.
  - 새로운 서비스를 개발할 때 그 서비스에 가장 알맞은 언어와 프레임워크를 자유롭게 선택할 수 있다. 

### 1.5.2 마이크로서비스 아키텍처 단점
- 딱 맞는 서비스를 찾기가 쉽지 않다.
  - 만약 시스템을 잘못 분해할 경우 아키텍처의 단점만 있는 분산 모놀리스를 구축하게 된다. 
  - 반드시 함계 배포해야 하는 결합도가 높은 서비스들로 이루어진 시스템이 탄생할 수 있다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
- 분산시스템 복잡하다. 
  - 서비스간 통신에 필수적인 IPC 역시 단순 메서드 호출보다는 복잡하다
  - 사용 불능 또는 지연 시간이 긴 원격서비스, 부분 실패한 서비스를 처리할 수있는 설계가 필요하다. 
- 여러 서비스에 걸친 공통 기능은 배포시 잘 살펴야 한다. 
- 도입 시기를 결정하기 어렵다.

## 1.6 마이크로서비스 아키텍처 패턴 언어

### 1.6.1 마이크로서비스 아키텍처도 만병통치약이 아니다.
- 마이크로서비스 역시 만병통치약이 아니고, 분명한 트레이드 오프가 존재한다. 

### 1.6.2 패턴 및 패턴 언어 
- 패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법입니다. 

#### 1.6.2.1 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈
- 주어진 맥락에서 문제를 해결하고자 할 떄 반드시 처리해야 할 강제 조항
- 강제조항을 명시적으로 나열하면 어느 이슈를 해결해야 할 지 명확해진다. 

#### 1.6.2.2 결과 맥락: 패턴 적용 결과 
- 장점: 패턴의 좋은점
- 단점: 패턴의 나쁜점
- 이슈: 패턴 적용 시 발생한 새로운 문제점

#### 1.6.2.3 연관 패턴
- 한 패턴과 다른 패턴의 관계를 기술하는 영역으로 5가지 종류가 있다. 
  - 선행자: 이 패턴을 필요하게 만든 선행 패턴 
  - 후행자: 이 패턴으로 야기된 이슈를 해결하는 패턴 
  - 대안: 이 패턴의 대체 솔루션을 제공하는 패턴
  - 일반화: 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
  - 세분화: 특정 패턴을 더 세부적으로 나타낸 형태 

### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요 
- 마이크로서비스 아키텍처 패턴 언어는 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집입니다. 
![마이크로패턴.jpg](imgs%2F%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%8C%A8%ED%84%B4.jpg)
- 패턴은 다시 3계층으로 분류됩니다. 
  - 인프라: 주로 개발 영역 밖의 인프라 문제
  - 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제
  - 애플리케이션 패펀: 개발자가 맞닥뜨리는 문제

#### 1.6.3.1 애플리케이션을 여러 서비스로 분해하는 패턴 
- 한 시스템을 여러 서비스로 분해하는 방법을 결정하는 것이 진짜 기술이며, 참고할 만한 유용한 전략이 존재한다. 
- 비지니스 능력에 따라 분배, 하위 도메인에 따라 분배(12장)

#### 1.6.3.2 통신 패턴 
- 마이크로서비스는 기본적으로 분산 시스템이기 때문에 프로세스 간 통신(IPC) 가 중요하다. 
- 통신스타일: 어떤 종류 IPC를 사용하는가?
- 디스커버리: 클라이언트는 서비스 인스턴스의 정보를 어떻게 가져오는가?
- 신뢰성: 서비스 불능시 서비스간 통신의 신뢰성은 어떻게 보장되는가?
- 트랜잭션널 메시징: DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
- 외부 API: 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가? 

#### 1.6.3.3 트랜잭션 관리를 위한 데이터 일관성 패턴 
- 각자 DB를 가지고 서로 느슨하게 결합하게 되면서 사가 패턴에 따라 데이터 일관성을 유지해야 한다. 

#### 1.6.3.4 데이터 쿼리 패턴 
- 서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제가 발생한다. 
- API 조합 패턴: 하나 이상의 서비스를 호출해서 그 결과를 조합하는 방식
- CQRS: 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리하는 방식 

#### 1.6.3.5 서비스 배포 패펀
- 마이크로서비스 애플리케이션은 다양한 언어와 프레임워크로 구현된 수십-수백 개의 서비스로 이루어져 있기 때문에 배포작업이 더 복잡하다.

#### 1.6.3.6 관측성 패턴: 애플리케이션 동작 파악
- 운영에 주 임무는 애플이케이션 런타임 동작을 이해하고, 요청실패, 높은 지연 시간 등 갖가지 문제를 진단/조치 하는 일이다. 
- 마이크로서비스 애플리케이션의 관측 가능한 서비스를 설계하려면 다음과 같은 패턴이 필요하다. 
  - 헬스 체크 API
  - 로그 수집: 서비스 내역을 기록하고, 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능
  - 분산 추적: 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적
  - 예외 추적: 예외가 발생시 예외 추적 서비스에 보고한다. 
  - 애플리케이션 지표: 카운터, 게이지 등의 지표를 측정
  - 감사 로깅: 사용자가 한 일을 기록

#### 1.6.3.7 서비스 테스트 자동화 패턴 
- 마이크로서비스는 서비스 크기가 작아서 테스트하기 쉽지만, 서로 다른 여러 서비스가 잘 작동되는지 테스트하는 일이 중요
- 컨슈머 주도 계약 테스트: 클라이언트가 의도한 대로 서비스가 동작하는지
- 컨슈머 쪽 계약 테스트: 클라이언트와 서비스가 상호 통신 가능한지
- 서비스 컴포넌트 테스트: 서비스를 따로 테스트한다. 

#### 1.6.3.8 횡단 관심사 처리 패턴 
- 마이크로서비스는 관측성, 디스커버리 패턴 등의 모든 서비스가 반드시 구현해야 할 관심사가 많고, 
DB 자격증명 같은 구성 매개변수를 런타임 서비스에 제공하는 외부화 구성 패턴을 사용해야 한다.
- 횡단 관심사를 처리하는 프레임워크에서는 마이크로서비스 새시패턴을 적용하는 것이 좋다.

#### 1.6.3.9 보안 패턴 
- api 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스를 수행한다. 

## 1.7 마이크로서비스 너머: 프로세스와 조직
### 1.7.1 소프트웨어 개발/전달 조직
- 크기가 N인 팀의 소통 오버헤드는 O(N의제곱) d으로 증가한다. 
- 규모가 큰 팀은 여러 팀으로 나누는 것이 좋다. 

### 1.7.2 소프트웨어 개발/전달 프로세스 
- 애자일 개발 프로세스를 도입하고 스크럼, 칸반 등을 실천해야 한다. 
- 지속적인 전달/배포를 실천도 필요하다. 
