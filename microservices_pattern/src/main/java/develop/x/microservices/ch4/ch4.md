# 4장 트랜잭션 관리:사가
- ACID: 트랜잭션이 제공하는 안전성 보장은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability) 를 의미
## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리
### 4.1.1 분산 트랜잭션의 필요성
- 데이터가 여러 서비스에 흩어져 있는 마이크로서비스 아키텍처에서는 단순하게 트랜잭션을 처리할 수 없다. 
- 서비스마다 DB가 따로 존재하기 떄문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야 한다.

### 4.1.2 분산 트랜잭션의 문제점 
- 예전에는 분산 트랜잭션을 이용해서 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터 일관성을 유지했다.
- X/Open DTP 모델은 트랜잭션 관리의 사실상 표준으로 XA는 2단계 커밋(2PC)을 이용하여 커밋 아니면 롤백을 하도록 보장했다. 
- 분산 트랜잭션은 NoSQL, 현대 메시지 브로커(RabbitMQ, 아파치 카프카)는 지원하지 않아 일부 기술을 포기해야 된다. 
- 동기 IPC 형태라서 가용성이 떨어지는 문제점도 존재

### 4.1.3 데이터 일관성 유지:사가 패턴
- 사가는 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘이다.
- 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의한다. (일련에 로컬 트랜잭션)
- 각 로컬 트랜잭션은 앞서 언급한 ACID 트랜잭션 프레임워크/라이브러리를 이용하여 서비스별 데이터를 업데이트 한다.
- 사가와 ACID 트랜잭션 차이
  - 하나 이상의 사가 참여자가 불능 상태인 경우에도 사가의 전체 단계을 실행시킬 수 있다. 
  - ACID 트랜잭션에 있는 격리성이 사가에는 없다.
  - 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백한다. 

#### 4.1.3.1 예제: 주문 생성 사가
- 주문 생성 사가 예제이며, 첫 번째 로컬 트랜잭션은 주문 생성이라는 외부 요청에 의 해 시작된다. 
- 주문 생성 사가는 6개의 로컬 트랜잭션으로 구성
  - 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
  - 소비자 서비스: 주문 가능한 소비자인지 확인
  - 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
  - 회계 서비스: 소비자 신용카드를 승인
  - 주방 서비스: 티켓 상태를 AWAITING_ACCEPTANCE 로 변경
  - 주문 서비스: 주문 상태를 APPROVED 로 변경

#### 4.1.3.2 사가는 보상 트랜잭션으로 변경분을 롤백한다. 
- 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능하다.
- 가령 주문 생성 사가 4번째 단계에서 신용카드 승인이 실패하면 1-3번째 단계에서 적용된 변경분을 명시적으로 언두해야 한다.
- (n+1) 번째 사가 트랜잭션이 실패하면 이전 n개의 트랜잭션을 언두해야 한다. 
- 읽기 전용 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요없다. 
- 소비자 신용카드 승인이 실패하면 보상 트랜잭션은 다음 순서대로 작동된다. 
  - 주문 서비스: 주문을 APPROVAL_PENDING 상태로 생성
  - 소비자 서비스: 주문 가능한 소비자인지 확인
  - 주방 서비스: 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성
  - 회계 서비스: 소비자 신용카드 승인 요청 거부
  - 주방 서비스: 티켓 상태를 CREATE_REJECTED 로 변경
  - 주문 서비스: 주문 상태를 REJECTED 로 변경

## 4.2 사가 편성
- 시스템 커맨드가 사가를 시작할 때 이 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고
- 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과장이 모든 단계가 실행될 때까지 반복
- 도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행
- 사가 편성 로직은 두 가지 종류가 있습니다.
  - 코레오그래피: 의사 결정과 순서화를 사가 참여자에 맡긴다. 사가 참여자는 주로 이벤트 교환 방식으로 통신
  - 오케스트레이션: 사가 편성 로직을 사가 오케스트레이터에 중앙화한다. 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시

### 4.2.1 코레오그래피 사가
- 코레오그래피 방식은 사가 참여자가 할 일을 알려 주는 중앙 편성자가 없다. 그 대신 사가 참여자가 서로 이벤트를 구독하는 방식

#### 4.2.1.1 주문 생성 사가 구현: 코레오그래피 스타일
- 사가 참여자는 서로 이벤트를 주고 받으며 소통한다. 
- 주문 서비스를 시작으로 각 참여자는 자신의 DB 를 업데이트하고 다음 참여자를 트리거하는 이벤트를 발행

#### 4.2.1.2 확실한 이벤트 기반 통신
- 코레오그래피 방식으로 사가를 구현하여 두 가지 통신 이슈를 고려해야 한다. 
  - 1 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션 일부로 이벤트를 발행하도록 해야한다. (원자적으로 발생해야 한다.)
  - 2 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관지을 수 있어야 한다.

#### 4.2.1.3 코레오그래피 사가의 장단점
- 코레오그래피 사가의 장점
  - 단순함: 비지니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트 발행
  - 느슨한 결합: 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.
- 코레오그래피 사가의 단점
  - 이해하기 어렵다: 사가 로직이 여러 서비스에 흩어져 있어 어떻게 동작하는지 파악하기 힘들다.
  - 서비스간 순환 의존성
  - 단단히 결함될 위험성
- 간단한 사가라면 코레오그래피 방식으로 충분하지만 복잡한 사가는 오케스트레이션 방식이 적합하다.


### 4.2.2 오케스트레이션 사가
- 오케스트레이션 사가에서는 사가 참여자가 할 일을 알려 주는 오케스트레이터 클래스를 정의한다. 
- 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신하게 된다. 

#### 4.2.2.1 주문 생성 사가 구현: 오케스트레이션 스타일
- 사가 오케스트레이터인 CreateOrderSaga 클래스가 비동기 요청/응답을 주고 받으면서 주방, 소비자 서비스 같은 사가 참여자를 호출하고
 그 처리 과정에 따라 커맨드 메시지를 전송합니다. 
- 여기서 주문 서비스는 오케스트레이터이면서 사가 참여자이기도 합니다.

#### 4.2.2.2 사가 오케스트레이션과 트랜잭셔널 메시징 
- 4.4 절에서 설명

#### 4.2.2.3 오케스트레이션 사가의 장단점
- 오케스트레이션 사가의 장점
  - 의존 관계 단순화 
  - 낮은 결합도
  - 관심사를 더 분리하고 비즈니스 로직을 단순화
- 오케스트레이션 사가의 단점
  - 오케스트레이터에 너무 많이 중앙화 하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수 있다.

## 4.3 비격리 문제 
- ACID 의 격리성은 동시에 실행 중이 여러 트랜잭션의 결과가 순서대로 실행된 결과와 동일함을 보장하는 속성이다. 
- 생성하고 읽기가 아니라 읽고 생성하는 현상이 발생할 수 있다. 

### 4.3.1 비정상 개요

#### 4.3.1.1 소실된 업데이트
- 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 쓸 때 일어납니다. 

#### 4.3.1.2 더티 읽기 
- 더티 읽기는 한 사가가 업데이트 중인 데이터를 다른 사가가 읽을 때 발생한다.

### 4.3.2 비격리 대책
- 개발자는 비격리로 인한 비정상을 방지하고 비지니스에 미치는 영향을 최소화하는 방향으로 사가를 작성할 의무가 있다. 

#### 4.3.2.1 사가의 구조
- 보상 가능 트랜잭션: 보상 트랜잭션으로 롤백 가능한 트랜잭션
- 피봇 트랜잭션: 사가의 진행/중단 지점, 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행된다. 이는 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수 있다.
- 재시도 가능 트랜잭션: 피봇 트랜잭션 직후의 트랜잭션, 반드시 성공한다.

#### 4.3.2.2 대책: 시맨틱 락
- 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책이다. 
- 플래그를 세팅해서 다른 트랙잭션이 레코드에 접근하지 못하게 락을 걸거나 경고할 수 있다. 

#### 4.3.2.3 대책: 교환적 업데이트
- 업데이트를 교환적으로, 즉 어떤 순서로도 실행가능하게 설게에서 소실된 업데이트 문제를 해결할 수 있다. 

#### 4.3.2.4 대책: 비관적 관점
- 더티 읽기로 인한 리스크를 최소화하기 위해 사가 단계 순서를 재조정하는 것이다. 

#### 4.3.2.5 대책: 값 다시 읽기
- 사가가 레코드를 업데이트 하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것이다. 
- 값을 다시 읽었더니 변경되었다면 사가를 중단하고 나중에 재시작한다.
- 일종의 낙관적 오프라인 락 패턴이다.

#### 4.3.2.6 대책: 버전 파일
- 버전 파일은 레코드에 수행한 작업을 하나하나 기록하는 대책이다. 
- 작업이 도착하면 기록해 두었다가 정확히 순서대로 실해하는 방식이다. 

#### 4.3.2.7 값에 의한 
- 비지니스 위험성을 기준으로 동시성 매커니즘을 선택하는 방식이다. 
- 각 요청의 속성을 보고 사가를 쓸지, 아니면 분산 트랜잭션을 쓸지 판단해서 수행한다.


## 4.4 주문 서비스 및 주문 생성 사가 설계
- 주문 서비스는 비지니스 로직이 있는 OrderService, Order 등의 클래스와 주문 생성 사가를 오케스트레이션하는 CreateOrderSaga 클래스가 존재한다.
- 사가 오케스레이터인 주문 서비스는 그 자신이 사가 참여자이기도 한 서비스이다. 


