# 3장 프로세스 간 통신

## 3.1 마이크로서비스 아키텍처 IPC 개요
- HTTP 기반 REST나 GRPC 등 동기 요청/응답 기반의 통신 매커니즘도 있고, AMQP, STOMP 등 비동기 메시지 기반은 통신 매커니즘도 있다.
- 메시지 포맷 역시 JSON, XML 처럼 읽을 수 있는 텍스트 포맷부터 아부로, 프로토콜 버퍼처럼 이진 포맷도 존재한다.

### 3.1.1 상호 작용 스타일 
- 클라이언트/서비스 상호 작용 스타일은 다양하지만 두 가지 기준으로 분류할 수 있다.
- 일대일/일대다
  - 일대일: 각 클라이언트 요청은 정확히 한 서비스가 처리
  - 일대다: 각 클라이언트 요청을 여러 서비스가 협도하여 처리
- 동기/비동기
  - 동기: 클라이언트는 응답을 대기한다.
  - 비동기: 클라이언트 블로킹하지 않고, 응답을 대기하지 않는다.
- 일대일 상호 작용
  - 요청/응답: 클라이언트는 서비스에 요청을 하고 응답을 기다립니다.
  - 비동기요청/응답: 클라이언트는 서비스에 요청을 하고, 서비스는 비동기적으로 응답합니다. 
  - 단방향 알림: 클라이언트 서비스에 일방적으로 요청만 합니다.
- 일대다 상호작용
  - 발행/구독: 클라이언트는 알림 메시지를 발생하고, 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비한다.
  - 발행/비동기 응답: 클라이언트는 알림 메시지를 발생하고, 주어진 시간 동안 관련 서비스가 응답하길 기다립니다.

### 3.1.2 마이크로서비스 API 정의 
- api 와 인터페이스는 소프트웨어 개발의 핵심이다. 애플리케이션은 여러 모듈로 구성되면, 각 모듈마다 자신의 클라이언트가 호출하는 작업이 정의된 인터페이스가 있다.
- 마이크로서비스 아키텍처에서는 api와 인터페이스가 둘 다 중요합니다. 서비스 api는 서비스와 클라이언트간의 약속이다. 

### 3.1.3 API 발전시키기
- 마이크로서비스은 클라이언트를 다른 서비스 팀이 개발한 경우가 대부분이기 때문에 서비스 API를 변경하기가 어렵다.

#### 3.1.3.1 시맨틱 버저닝 
- MAJOR: 하위 호환되지 않는 변경분을 API 적용시
- MINOR: 하위 호환되는 변경분을 API 적용시
- PATCH: 하위 호환되는 오류 수정시

#### 3.1.3.2 하위 호환되는 소규모 변경
- 요청 속성이 누락되어도 서비스는 기본값을 제공하고, 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 무시해야 한다.

#### 3.1.3.3 중대한 대규모 변경
- 기존 버전과 호환이 안 되는 변경을 API에 적용해야 할 때가 있습니다. 
- 일시에 클라이언트를 강제로 업그레이드 하는 것은 불가하므로 일정 기간 동안 신구 버전 API를 모두 지원해야 한다.

### 3.1.3 메시지 포맷
- IPC의 핵심은 메시지 교환입니다. IPC 효율, API 사용성, 발전성에 영향을 미친다. 
- 텍스트 메시지 포맷
  - JSON, XML 등 텍스트 기반 포맷은 읽을 수 있고 자기 서술적이라는 장점이 있습니다. 
  - 단점은 메시지 길다는 점과 텍스트 파싱하는 오버헤드가 존재한다.
- 이진 메시지 포맷
  - 프로토콜 버퍼와 아브로가 유명하며, 이들은 메시지 구조 정의필요한 타입 IDL을 제공하며, 컴파일러는 메시지를 직렬화/역직렬화 하는 코드를 생성한다. 
  - 따라서 서비스를 API 우선 접근 방식으로 설계 된다. 

## 3.2 동기 RPI 패턴 응용 통신
- RPI 는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회산하는 IPC 입니다. 
- 대기중에 블로킹하는 클라이언트도 있고, 리액티브한 논블로킹 아키텍처를 가진 클라이언트도 있습니다. 

### 3.2.1 동기 RPI 패턴:REST
- REST 는 거의 항상 HTTP 로 소통하는 IPC 입니다. 리소스는 REST 의 핵심 개념으로 사용된다. 

#### 3.2.1.1 REST 성숙도 모델
- 레벨 0: 
  - 클라이언트 서비스별로 유일한 URL 끝점에 POST 요청을 하여 서비스를 호출합니다. 
  - 요청을 할 때마다 어떤 액션을 수행할지, 그 대상은 무엇인지 지정합니다. 
- 레벨 1:
  - 서비스는 리소스 개념을 지원합니다. 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청을 합니다.
- 레벨 2:
  - 서비스는 HTTP 동사를 이용해서 액션을 수행하고, 요청 쿼리 매개변수 및 본문 필요시 매개변수를 지정합니다. 
  - 덕분에 GET 요청을 캐싱하는 등 웹 인프라를 활용할 수 있다. 
- 레벨 3: 
  - 서비스를 HATEOAS 원칙에 기반하여 설계한다. 
  - HATEOAS 는 GET 요청으로 반환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내자는 생각
  - HATEOAS 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여넣지 않아도 된다. 
```json
{
  "id": 100,
  "subject": "게시글 100",
  "content": "내용",
  "_links": {
    "self": {
      "href": "https://my-test-server.com/api/articles/100"
    },
    "next": {
      "href": "https://my-test-server.com/api/articles/101"
    },
    "like": {
      "href": "https://my-test-server.com/api/articles/likes"
    },
    "comment": {
      "href": "https://my-test-server.com/api/articles/100/comments"
    },
    "home": {
      "href": "https://my-test-server.com/"
    }
  }
}
```


#### 3.2.1.2 REST API 
- 스웨거라는 오픈 소스를 발전시켜 오픈 API 명세가 REST IDL 로서 널리 보급되었다.

#### 3.2.1.3 요청 한 번으로 많은 리소스를 가져오기 어렵다.
- HTTP 통신시 한번에 요청으로 여러 리소스를 가져오지 못한다. 
- 그래서 GraphQL이나 넷플릭스 팔코 등의 대체 API 기술이 각광받기 시작했다. 

#### 3.2.1.4 작업을 HTTP 동사에 매핑하기 업력다. 
- REST API로 데이터 수정시 대개 PUT 동사를 쓰지만 주문 취소/변경 등의 요건이 발생할 수 있는데 이를 매핑하기가 어렵다는 점이 있다. 
- 그래서 하위 리소스를 정의해서 이를 해결하기도 한다.
```text
/order/{orderId}/cancel (취소)
/order/{orderId}/revise (변경)
```

### 3.2.2 동기 RPI 패턴 gRPC
- gRPC 는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크 입니다. 
- 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수 밖에 없다. 
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2 를 통해 교환한다.

### 3.2.3 부분 실패 처리: 회로 차단기 패턴 
- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 존재한다. 
- 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시다
  
#### 3.2.3.1 견고가 RPI 프록시 설계
- 네트워크 타임아웃: 
  - 응답 대기 중에 무한정 블로킹하면 안 되고, 항상 타임아웃을 걸어 둡니다.
- 미처리 요청 개수 제한:
  - 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정합니다.
  - 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리하는 것이 타당하다.
- 회로 차단기 패턴: 성공/실패 요청 갯수 지켜보다는 애러율이 주어진 임계치를 초과하면 그 이상의 요청은 무의미하다는 뜻이다. 

#### 3.2.3.1 불능 서비스 복구
- 무응답원격 서비스를 어떻게복구하면 좋을지는 상황에 따라 판단해야 된다. 
- 클라이언트에게 애러를 반환하는 방법도 있고, 캐쉬에 있는 데이터를 대신 전달하는 방법도 있다. 


### 3.2.4 서비스 디스커버리
- REST API 가 있는 어떤 서비스를 호출하기 위해서는 서비스 인스턴스의 네트워크 위치(IP/port)를 알고 있어야 요청을 할 수 있다. 
- 클라우드 기반의 마이크로서비스는 네트워크 위치가 동적으로 변경되어 이를 식별하는 일이 간단하지 않다.

#### 3.2.4.1 서비스 디스커버리 개요
- 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리이다. 
- 클라이언트가 서비스를 호출하면 우선 서비스 디스커리가 서비스 레지스트리에서 가용 서비스 인스턴스 목록을 가져오고, 그 중 한 서비스로 요청을 라우팅 합니다. 

#### 3.2.4.2 애플리케이션 수준의 서비스 디스커버리 패턴 적용
- 애플리케이션 클라이언트/서비스가 서비스 레지스트리와 직접 통신하는 방식
- 서비스 인스턴스는 서비스 레지스트리에 자기 자신을 등록한다(자가 등록 패턴)
- 클라이언트는 서비스 호출 전에 서비스 레지스트리에 서비스 인스턴스 목록을 요청해서 넘겨받고, 부하 분산 알고리즘을 이용하여 서비스 인스턴스를 선택한다.

#### 3.2.4.3 플랫폼에 내장된 서비스 디스커버리 패턴 적용
- 도커나 쿠버네티스 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 매커니즘이 탑제되어 있다. 
- 서비스 클라이언트가 DNS명/VIP를 요청하면 배포 플랫폼이 알아서 가용 서비스 인스턴스 중 하나로 요청을 라우팅합니다. 
- 서드파티 등록 패턴: 서비스가 자신을 등록하는 것이 아니라 배포 플랫폼의 일부인 등록기라는 서드파티가 이 작업을 대행합니다. 
- 서버 쪽 디스커버리 패턴: 클라이언트가 서비스 레지스트리를 질의하지 않고 DNS 명을 요청합니다. 


## 3.3 비동기 메시징 패턴 응용 통신
- 메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식입니다. 
- 메시징 기반의 애플리케이션은 보통 서비스 간 중개 역할을 하는 메시지 브로커를 사용하지만 서비스가 직접 서로 통신하는 브로커리스 아키텍처도 있다. 

### 3.3.1 메시징 개요

#### 3.3.1.1 메시지
- 메시지는 헤더와 본문으로 구성됩니다. 
- 헤더에는 송신된 데이터에 관한 메타 데이터에 해당하는 키/값으로 구성된다. 
- 메시지 본문은 실제로 송신할 텍스트 또는 이진 포맷의 데이터이다. 

#### 3.3.1.2 메시지 채널
- 송신자의 비즈니스 로직은 하부 통신 매커니즘을 캡슐화한 송신 포트 인터페이스를 호출합니다. 
- 수신자의 메시지 핸들러 어댑터 클래스는 메시지를 처리하기 위해 호출되고, 이 클래스는 컨슈머 비지니스 로직으로 구현된 수신 포트 인터페이스를 호출한다.
- 채널은 두종류가 있다.
  - 점대점 채널
  - 발행-구독 채널

### 3.3.2 메시징 상호 작용 스타일 구현

#### 3.3.2.1 요청/응답 및 비동기 요청/응답
- 요청/응답 및 비동기 요청/응답 모두 클라이언트가 요청을 보내면 서비스는 응답을 반환한다. 
- 메시징은 원래 비동기만 제공하지만 응답을 수신할 때까지 클라이언트를 블로킹 할 수 있다. 
- 점대점 채널의 경우만 가능한 형태이다. 

#### 3.3.2.2 단방향 알림
- 서비스가 소유한 점대점 채널로 클라이언트가 메시지를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조
- 단방향이므로 서비스는 응답을 반환하지 않는다. 

#### 3.3.2.3 발행/구독
- 클라이언트는 여러 컨슈머가 읽는 발행/구독 채널에 메시지를 발행하고, 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행합니다. 

#### 3.3.2.4 발행/비동기 응답
- 클라이언트는 응답 채널 헤더가 명시된 메시지를 발행/구독 채널에 발행한다. 
- 컨슈머는 id가 포함된 응답 메시지를 지정된 응답 채널에 쏜다.
- 클라이언트는 id로 응답을 취합하여 응답 메시지와 요청을 맞추어 본다.

### 3.3.3 메시징 기반 서비스의 API 명세 작성
- 비동기 작업 문서화
  - 요청/비동기 응답 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷, 
  서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성된다.
  - 단방향 알림 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성
- 발행 이벤트 문서화
  - 서비스는 발행/구독 스타일로 이벤트를 발행할 수 있다. 
  - 이경우 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성된다. 

### 3.3.4 메시지 브로커
- 메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스이다.

#### 3.3.4.1 브로커리스 메시징 
- 브로커리스 아키텍처의 서비스는 메시지를 서로 직접 교환한다. ZeroMQ는 잘 알려진 브러커리스 메시징 기술이다.

#### 3.3.4.2 브로커 기반 메시징 개요
- 송신자가 메시지 브로커에 메시지를 쓰면 메시지 브로커는 메시지를 수신자에게 전달한다. 
- 메시지 브로커의 가장 큰 장점은 송신자가 컨슈머 네트워크 위치를 몰라도 된다는 점이다. 
- 컨슈머가 메시지를 처리할 수 있을 때까지 메시지 브로커에 메시지를 버퍼링할 수 도 있다. 
- ActiveMQ
- RebbitMQ
- 아파치 카프카

#### 3.3.4.3 메시지 브로커로 메시지 채널 구현 
- 메시지 채널은 메시지 브로커마다 구현 방식이 다르다. 
  - ActiveMQ 같은 JMS 메시지 브로커에는 큐와 토픽
  - RebbitMQ 같은 AMQP 기반의 메시지 브로커에는 익스체인지와 큐
  - 아파피 카프카는 토픽 

#### 3.3.4.4 브로커 기반 메시징의 장단점
- 브로커 기반의 메시징 장점
  - 느슨한 결합, 메시지 버퍼링, 유연한 통신, 명시적 IPC
- 브로커 기반의 메시징 단점
  - 성능 병목 가능성, 단일 장애점 가능성, 운영 복잡도

### 3.3.5 수신자 경합과 메시지 순서 유지
- 메시지 순서를 달라지면 클라이언트 입장에서는 원하는 결과가 나오지 않을 수 있다. 주문, 취소 요청을 했는데 취소가 먼저 발생할 수 있다. 
- 샤딩된 채널은 요청 키에 따라 파티셔닝 된 채널에게 요청을 처리하도록 하는 방식

### 3.3.6 중복 메시지 처리 
- 멱등한 메시지 핸들러 작성 
  - 동일한 입력 값을 반복 호출해도 부수 효과가 없을 때 멱등하다고 말합니다. 
  - 메시지 추적과 중복 메시지 솎아 내기

### 3.3.7 트랜잭셔널 메시징 
- 서비스는 보통 DB 를 업데이트하는 트랜잭션의 일부로 메시지를 발행합니다. 
- DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않으면, DB 업데이트 후 메시지는 아직 전송되지 않은 상태일 수 있다.

#### 3.3.7.1 DB 테이블을 메시지 큐로 활용
- RDBMS 기반의 애플리케이션은 DB 테이블을 임시 메시지 큐로 사용하는 트랜잭셔널 아웃박스 패턴이 가장 알기 쉬운 방법이다. 

#### 3.3.7.2 이벤트 발행: 풀링 발행기 패턴
- DB에 있는 아웃박스를 풀링해서 미발행 메시지를 조회하여 발행하는 방법

#### 3.3.7.3 이벤트 발행: 트랜잭션 로그 테일링 패턴 
- 메시지 릴레이로 DB 트랜잭션 로그를 테일링 하는 방법입니다. 
- 커밋된 업데이트는 각 DB의 트랜잭션 로그 항목으로 남는데 이를 읽어 변경분을 하나씩 메시지로 메시지 브로커에 발행

### 3.3.8 메시징 라이브러리/프레임워크
- 이벤추에이트 트램 프레임워크: 메시지 브로커의 사용 복잡성을 캡슐해서 api 를 제공하는 프레임워크
  - 트랜잭셔널 메시징: 메시지를 DB 트랜잭션의 일부로 발행
  - 중복 메시지 감지

## 3.4 비동기 메시징으로 가용성 개선
- 요청을 처리하는 과정에서 타 서비스와 동기 통신을 하면 그만큼 가용성이 떨어지므로 가능한 서비스가 비동기 메시징을 이용하여
 통신하도록 설계하는 것이 좋습니다. 

### 3.4.1 동기 통신으로 인한 가용성 저하
- REST는 동기 프로토콜이라는 치명적인 문제가 있어 호출한 서비스가 응답할 때까지 기다려야 한다. 
- 동기 프로토콜로 통신하면 애플리케이션 가용성은 저하될 수 밖에 없다. 

### 3.4.2 동기 상호 작용 제거

#### 3.4.2.1 비동기 상호 작용 스타일
- 클라이언트도 비동기 요청/응답 상호 작용을 통해 주문을 요청하고, 서비스도 역시 다른 서비스들과 비동기 방식으로 교환하고 클라이언트에게 응답을 내려준다.
- 이런 상호 과정에서 어느 쪽도 응답을 대기하며 블로킹 되지 않기 때문에 가용성이 향상됩니다. 
- 그러나 REST 같은 동기 프로토콜을 사용하기 떄문에 요청에 즉시 응답해야 하는 외부 API 에서는 사용할 수 없다. 

#### 3.4.1.2 데이터 복제 
- 서비스 요청 처리에 필요한 데이터의 레즐리카를 유지하는 방법이다. 
- 데이터 레즐리카는 데이터를 소유한 서비스가 발행하는 이벤트를 구독해서 최신 데이터를 유지할 수 있다. 

#### 3.4.1.3 응답 반환 후 마무리 
- 요청 처리 도중 동기 통신을 제거하려면 요청을 다음과 같이 처리할 수 있다. 
  - 1 주문 서비스는 주문을 pending 상태로 생성
  - 2 주문 서비스는 주문 ID가 포함된 응답을 클라이언트에 반환
  - 3 주문 서비스는 음식적 서비스에게 음식을 요청합니다.
  - 4 음식점 서비스는 음식을 제공여부를 확인 후 주문 서비스에서 가능/불가능 여부를 전달합니다. 
  - 5 가능/불가능인 경우 주문 서비스는 해당 주문 ID 의 상태를 변경합니다. 





